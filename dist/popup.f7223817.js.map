{"mappings":"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","sources":["<anon>","popup.js","node_modules/marked/lib/marked.umd.js","node_modules/marked/src/defaults.ts","node_modules/marked/src/rules.ts","node_modules/marked/src/helpers.ts","node_modules/marked/src/Tokenizer.ts","node_modules/marked/src/Lexer.ts","node_modules/marked/src/Renderer.ts","node_modules/marked/src/TextRenderer.ts","node_modules/marked/src/Parser.ts","node_modules/marked/src/Hooks.ts","node_modules/marked/src/Instance.ts","node_modules/marked/src/marked.ts"],"sourcesContent":["var $d55025bea272cdc1$exports = {};\n/**\n * marked v15.0.11 - a markdown parser\n * Copyright (c) 2011-2025, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */ /**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */ (function(global, factory) {\n    factory($d55025bea272cdc1$exports);\n})($d55025bea272cdc1$exports, function(exports1) {\n    'use strict';\n    /**\n     * Gets the original marked default options.\n     */ function _getDefaults() {\n        return {\n            async: false,\n            breaks: false,\n            extensions: null,\n            gfm: true,\n            hooks: null,\n            pedantic: false,\n            renderer: null,\n            silent: false,\n            tokenizer: null,\n            walkTokens: null\n        };\n    }\n    exports1.defaults = _getDefaults();\n    function changeDefaults(newDefaults) {\n        exports1.defaults = newDefaults;\n    }\n    const noopTest = {\n        exec: ()=>null\n    };\n    function edit(regex, opt = '') {\n        let source = typeof regex === 'string' ? regex : regex.source;\n        const obj = {\n            replace: (name, val)=>{\n                let valSource = typeof val === 'string' ? val : val.source;\n                valSource = valSource.replace(other.caret, '$1');\n                source = source.replace(name, valSource);\n                return obj;\n            },\n            getRegex: ()=>{\n                return new RegExp(source, opt);\n            }\n        };\n        return obj;\n    }\n    const other = {\n        codeRemoveIndent: /^(?: {1,4}| {0,3}\\t)/gm,\n        outputLinkReplace: /\\\\([\\[\\]])/g,\n        indentCodeCompensation: /^(\\s+)(?:```)/,\n        beginningSpace: /^\\s+/,\n        endingHash: /#$/,\n        startingSpaceChar: /^ /,\n        endingSpaceChar: / $/,\n        nonSpaceChar: /[^ ]/,\n        newLineCharGlobal: /\\n/g,\n        tabCharGlobal: /\\t/g,\n        multipleSpaceGlobal: /\\s+/g,\n        blankLine: /^[ \\t]*$/,\n        doubleBlankLine: /\\n[ \\t]*\\n[ \\t]*$/,\n        blockquoteStart: /^ {0,3}>/,\n        blockquoteSetextReplace: /\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g,\n        blockquoteSetextReplace2: /^ {0,3}>[ \\t]?/gm,\n        listReplaceTabs: /^\\t+/,\n        listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,\n        listIsTask: /^\\[[ xX]\\] /,\n        listReplaceTask: /^\\[[ xX]\\] +/,\n        anyLine: /\\n.*\\n/,\n        hrefBrackets: /^<(.*)>$/,\n        tableDelimiter: /[:|]/,\n        tableAlignChars: /^\\||\\| *$/g,\n        tableRowBlankLine: /\\n[ \\t]*$/,\n        tableAlignRight: /^ *-+: *$/,\n        tableAlignCenter: /^ *:-+: *$/,\n        tableAlignLeft: /^ *:-+ *$/,\n        startATag: /^<a /i,\n        endATag: /^<\\/a>/i,\n        startPreScriptTag: /^<(pre|code|kbd|script)(\\s|>)/i,\n        endPreScriptTag: /^<\\/(pre|code|kbd|script)(\\s|>)/i,\n        startAngleBracket: /^</,\n        endAngleBracket: />$/,\n        pedanticHrefTitle: /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/,\n        unicodeAlphaNumeric: /[\\p{L}\\p{N}]/u,\n        escapeTest: /[&<>\"']/,\n        escapeReplace: /[&<>\"']/g,\n        escapeTestNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/,\n        escapeReplaceNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/g,\n        unescapeTest: /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig,\n        caret: /(^|[^\\[])\\^/g,\n        percentDecode: /%25/g,\n        findPipe: /\\|/g,\n        splitPipe: / \\|/,\n        slashPipe: /\\\\\\|/g,\n        carriageReturn: /\\r\\n|\\r/g,\n        spaceLine: /^ +$/gm,\n        notSpaceStart: /^\\S*/,\n        endingNewline: /\\n$/,\n        listItemRegex: (bull)=>new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`),\n        nextBulletRegex: (indent)=>new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`),\n        hrRegex: (indent)=>new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`),\n        fencesBeginRegex: (indent)=>new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`),\n        headingBeginRegex: (indent)=>new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),\n        htmlBeginRegex: (indent)=>new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, 'i')\n    };\n    /**\n     * Block-Level Grammar\n     */ const newline = /^(?:[ \\t]*(?:\\n|$))+/;\n    const blockCode = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/;\n    const fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\n    const hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\n    const heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\n    const bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n    const lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/;\n    const lheading = edit(lheadingCore).replace(/bull/g, bullet) // lists can interrupt\n    .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n    .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n    .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n    .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n    .replace(/\\|table/g, '') // table not in commonmark\n    .getRegex();\n    const lheadingGfm = edit(lheadingCore).replace(/bull/g, bullet) // lists can interrupt\n    .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n    .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n    .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n    .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n    .replace(/table/g, / {0,3}\\|?(?:[:\\- ]*\\|)+[\\:\\- ]*\\n/) // table can interrupt\n    .getRegex();\n    const _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\n    const blockText = /^[^\\n]+/;\n    const _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\n    const def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/).replace('label', _blockLabel).replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/).getRegex();\n    const list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/).replace(/bull/g, bullet).getRegex();\n    const _tag = \"address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul\";\n    const _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\n    const html = edit(\"^ {0,3}(?:<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)|comment[^\\\\n]*(\\\\n+|$)|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$)|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$)|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$))\", 'i').replace('comment', _comment).replace('tag', _tag).replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\n    const paragraph = edit(_paragraph).replace('hr', hr).replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)').replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n    .replace('|table', '').replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex();\n    const blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/).replace('paragraph', paragraph).getRegex();\n    /**\n     * Normal Block Grammar\n     */ const blockNormal = {\n        blockquote: blockquote,\n        code: blockCode,\n        def: def,\n        fences: fences,\n        heading: heading,\n        hr: hr,\n        html: html,\n        lheading: lheading,\n        list: list,\n        newline: newline,\n        paragraph: paragraph,\n        table: noopTest,\n        text: blockText\n    };\n    /**\n     * GFM Block Grammar\n     */ const gfmTable = edit(\"^ *([^\\\\n ].*)\\\\n {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)\") // Cells\n    .replace('hr', hr).replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)').replace('blockquote', ' {0,3}>').replace('code', '(?: {4}| {0,3}\\t)[^\\\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n    .getRegex();\n    const blockGfm = {\n        ...blockNormal,\n        lheading: lheadingGfm,\n        table: gfmTable,\n        paragraph: edit(_paragraph).replace('hr', hr).replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)').replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n        .replace('table', gfmTable) // interrupt paragraphs with table\n        .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n        .getRegex()\n    };\n    /**\n     * Pedantic grammar (original John Gruber's loose markdown specification)\n     */ const blockPedantic = {\n        ...blockNormal,\n        html: edit(\"^ *(?:comment *(?:\\\\n|\\\\s*$)|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)|<tag(?:\\\"[^\\\"]*\\\"|'[^']*'|\\\\s[^'\\\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))\").replace('comment', _comment).replace(/tag/g, \"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b\").getRegex(),\n        def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n        heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n        fences: noopTest,\n        lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n        paragraph: edit(_paragraph).replace('hr', hr).replace('heading', ' *#{1,6} *[^\\n]').replace('lheading', lheading).replace('|table', '').replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').replace('|tag', '').getRegex()\n    };\n    /**\n     * Inline-Level Grammar\n     */ const escape$1 = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\n    const inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\n    const br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\n    const inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n    // list of unicode punctuation marks, plus any missing characters from CommonMark spec\n    const _punctuation = /[\\p{P}\\p{S}]/u;\n    const _punctuationOrSpace = /[\\s\\p{P}\\p{S}]/u;\n    const _notPunctuationOrSpace = /[^\\s\\p{P}\\p{S}]/u;\n    const punctuation = edit(/^((?![*_])punctSpace)/, 'u').replace(/punctSpace/g, _punctuationOrSpace).getRegex();\n    // GFM allows ~ inside strong and em for strikethrough\n    const _punctuationGfmStrongEm = /(?!~)[\\p{P}\\p{S}]/u;\n    const _punctuationOrSpaceGfmStrongEm = /(?!~)[\\s\\p{P}\\p{S}]/u;\n    const _notPunctuationOrSpaceGfmStrongEm = /(?:[^\\s\\p{P}\\p{S}]|~)/u;\n    // sequences em should skip over [title](link), `code`, <html>\n    const blockSkip = /\\[[^[\\]]*?\\]\\((?:\\\\.|[^\\\\\\(\\)]|\\((?:\\\\.|[^\\\\\\(\\)])*\\))*\\)|`[^`]*?`|<[^<>]*?>/g;\n    const emStrongLDelimCore = /^(?:\\*+(?:((?!\\*)punct)|[^\\s*]))|^_+(?:((?!_)punct)|([^\\s_]))/;\n    const emStrongLDelim = edit(emStrongLDelimCore, 'u').replace(/punct/g, _punctuation).getRegex();\n    const emStrongLDelimGfm = edit(emStrongLDelimCore, 'u').replace(/punct/g, _punctuationGfmStrongEm).getRegex();\n    const emStrongRDelimAstCore = \"^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\\\*)punct(\\\\*+)(?=[\\\\s]|$)|notPunctSpace(\\\\*+)(?!\\\\*)(?=punctSpace|$)|(?!\\\\*)punctSpace(\\\\*+)(?=notPunctSpace)|[\\\\s](\\\\*+)(?!\\\\*)(?=punct)|(?!\\\\*)punct(\\\\*+)(?!\\\\*)(?=punct)|notPunctSpace(\\\\*+)(?=notPunctSpace)\"; // (6) a***a can be either Left or Right Delimiter\n    const emStrongRDelimAst = edit(emStrongRDelimAstCore, 'gu').replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();\n    const emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, 'gu').replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm).replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm).replace(/punct/g, _punctuationGfmStrongEm).getRegex();\n    // (6) Not allowed for _\n    const emStrongRDelimUnd = edit(\"^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)\", 'gu') // (5) #___# can be either Left or Right Delimiter\n    .replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();\n    const anyPunctuation = edit(/\\\\(punct)/, 'gu').replace(/punct/g, _punctuation).getRegex();\n    const autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/).replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();\n    const _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\n    const tag = edit(\"^comment|^</[a-zA-Z][\\\\w:-]*\\\\s*>|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>|^<\\\\?[\\\\s\\\\S]*?\\\\?>|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\") // CDATA section\n    .replace('comment', _inlineComment).replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/).getRegex();\n    const _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n    const link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:(?:[ \\t]*(?:\\n[ \\t]*)?)(title))?\\s*\\)/).replace('label', _inlineLabel).replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^ \\t\\n\\x00-\\x1f]*/).replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/).getRegex();\n    const reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/).replace('label', _inlineLabel).replace('ref', _blockLabel).getRegex();\n    const nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/).replace('ref', _blockLabel).getRegex();\n    const reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g').replace('reflink', reflink).replace('nolink', nolink).getRegex();\n    /**\n     * Normal Inline Grammar\n     */ const inlineNormal = {\n        _backpedal: noopTest,\n        anyPunctuation: anyPunctuation,\n        autolink: autolink,\n        blockSkip: blockSkip,\n        br: br,\n        code: inlineCode,\n        del: noopTest,\n        emStrongLDelim: emStrongLDelim,\n        emStrongRDelimAst: emStrongRDelimAst,\n        emStrongRDelimUnd: emStrongRDelimUnd,\n        escape: escape$1,\n        link: link,\n        nolink: nolink,\n        punctuation: punctuation,\n        reflink: reflink,\n        reflinkSearch: reflinkSearch,\n        tag: tag,\n        text: inlineText,\n        url: noopTest\n    };\n    /**\n     * Pedantic Inline Grammar\n     */ const inlinePedantic = {\n        ...inlineNormal,\n        link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace('label', _inlineLabel).getRegex(),\n        reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace('label', _inlineLabel).getRegex()\n    };\n    /**\n     * GFM Inline Grammar\n     */ const inlineGfm = {\n        ...inlineNormal,\n        emStrongRDelimAst: emStrongRDelimAstGfm,\n        emStrongLDelim: emStrongLDelimGfm,\n        url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i').replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),\n        _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n        del: /^(~~?)(?=[^\\s~])((?:\\\\.|[^\\\\])*?(?:\\\\.|[^\\s~\\\\]))\\1(?=[^~]|$)/,\n        text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n    };\n    /**\n     * GFM + Line Breaks Inline Grammar\n     */ const inlineBreaks = {\n        ...inlineGfm,\n        br: edit(br).replace('{2,}', '*').getRegex(),\n        text: edit(inlineGfm.text).replace('\\\\b_', '\\\\b_| {2,}\\\\n').replace(/\\{2,\\}/g, '*').getRegex()\n    };\n    /**\n     * exports\n     */ const block = {\n        normal: blockNormal,\n        gfm: blockGfm,\n        pedantic: blockPedantic\n    };\n    const inline = {\n        normal: inlineNormal,\n        gfm: inlineGfm,\n        breaks: inlineBreaks,\n        pedantic: inlinePedantic\n    };\n    /**\n     * Helpers\n     */ const escapeReplacements = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#39;'\n    };\n    const getEscapeReplacement = (ch)=>escapeReplacements[ch];\n    function escape(html, encode) {\n        if (encode) {\n            if (other.escapeTest.test(html)) return html.replace(other.escapeReplace, getEscapeReplacement);\n        } else {\n            if (other.escapeTestNoEncode.test(html)) return html.replace(other.escapeReplaceNoEncode, getEscapeReplacement);\n        }\n        return html;\n    }\n    function cleanUrl(href) {\n        try {\n            href = encodeURI(href).replace(other.percentDecode, '%');\n        } catch  {\n            return null;\n        }\n        return href;\n    }\n    function splitCells(tableRow, count) {\n        // ensure that every cell-delimiting pipe has a space\n        // before it to distinguish it from an escaped pipe\n        const row = tableRow.replace(other.findPipe, (match, offset, str)=>{\n            let escaped = false;\n            let curr = offset;\n            while(--curr >= 0 && str[curr] === '\\\\')escaped = !escaped;\n            if (escaped) // odd number of slashes means | is escaped\n            // so we leave it alone\n            return '|';\n            else // add space before unescaped |\n            return ' |';\n        }), cells = row.split(other.splitPipe);\n        let i = 0;\n        // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n        if (!cells[0].trim()) cells.shift();\n        if (cells.length > 0 && !cells.at(-1)?.trim()) cells.pop();\n        if (count) {\n            if (cells.length > count) cells.splice(count);\n            else while(cells.length < count)cells.push('');\n        }\n        for(; i < cells.length; i++)// leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(other.slashPipe, '|');\n        return cells;\n    }\n    /**\n     * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n     * /c*$/ is vulnerable to REDOS.\n     *\n     * @param str\n     * @param c\n     * @param invert Remove suffix of non-c chars instead. Default falsey.\n     */ function rtrim(str, c, invert) {\n        const l = str.length;\n        if (l === 0) return '';\n        // Length of suffix matching the invert condition.\n        let suffLen = 0;\n        // Step left until we fail to match the invert condition.\n        while(suffLen < l){\n            const currChar = str.charAt(l - suffLen - 1);\n            if (currChar === c && true) suffLen++;\n            else break;\n        }\n        return str.slice(0, l - suffLen);\n    }\n    function findClosingBracket(str, b) {\n        if (str.indexOf(b[1]) === -1) return -1;\n        let level = 0;\n        for(let i = 0; i < str.length; i++){\n            if (str[i] === '\\\\') i++;\n            else if (str[i] === b[0]) level++;\n            else if (str[i] === b[1]) {\n                level--;\n                if (level < 0) return i;\n            }\n        }\n        if (level > 0) return -2;\n        return -1;\n    }\n    function outputLink(cap, link, raw, lexer, rules) {\n        const href = link.href;\n        const title = link.title || null;\n        const text = cap[1].replace(rules.other.outputLinkReplace, '$1');\n        lexer.state.inLink = true;\n        const token = {\n            type: cap[0].charAt(0) === '!' ? 'image' : 'link',\n            raw: raw,\n            href: href,\n            title: title,\n            text: text,\n            tokens: lexer.inlineTokens(text)\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    function indentCodeCompensation(raw, text, rules) {\n        const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);\n        if (matchIndentToCode === null) return text;\n        const indentToCode = matchIndentToCode[1];\n        return text.split('\\n').map((node)=>{\n            const matchIndentInNode = node.match(rules.other.beginningSpace);\n            if (matchIndentInNode === null) return node;\n            const [indentInNode] = matchIndentInNode;\n            if (indentInNode.length >= indentToCode.length) return node.slice(indentToCode.length);\n            return node;\n        }).join('\\n');\n    }\n    /**\n     * Tokenizer\n     */ class _Tokenizer {\n        options;\n        rules;\n        lexer;\n        constructor(options){\n            this.options = options || exports1.defaults;\n        }\n        space(src) {\n            const cap = this.rules.block.newline.exec(src);\n            if (cap && cap[0].length > 0) return {\n                type: 'space',\n                raw: cap[0]\n            };\n        }\n        code(src) {\n            const cap = this.rules.block.code.exec(src);\n            if (cap) {\n                const text = cap[0].replace(this.rules.other.codeRemoveIndent, '');\n                return {\n                    type: 'code',\n                    raw: cap[0],\n                    codeBlockStyle: 'indented',\n                    text: !this.options.pedantic ? rtrim(text, '\\n') : text\n                };\n            }\n        }\n        fences(src) {\n            const cap = this.rules.block.fences.exec(src);\n            if (cap) {\n                const raw = cap[0];\n                const text = indentCodeCompensation(raw, cap[3] || '', this.rules);\n                return {\n                    type: 'code',\n                    raw: raw,\n                    lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n                    text: text\n                };\n            }\n        }\n        heading(src) {\n            const cap = this.rules.block.heading.exec(src);\n            if (cap) {\n                let text = cap[2].trim();\n                // remove trailing #s\n                if (this.rules.other.endingHash.test(text)) {\n                    const trimmed = rtrim(text, '#');\n                    if (this.options.pedantic) text = trimmed.trim();\n                    else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n                return {\n                    type: 'heading',\n                    raw: cap[0],\n                    depth: cap[1].length,\n                    text: text,\n                    tokens: this.lexer.inline(text)\n                };\n            }\n        }\n        hr(src) {\n            const cap = this.rules.block.hr.exec(src);\n            if (cap) return {\n                type: 'hr',\n                raw: rtrim(cap[0], '\\n')\n            };\n        }\n        blockquote(src) {\n            const cap = this.rules.block.blockquote.exec(src);\n            if (cap) {\n                let lines = rtrim(cap[0], '\\n').split('\\n');\n                let raw = '';\n                let text = '';\n                const tokens = [];\n                while(lines.length > 0){\n                    let inBlockquote = false;\n                    const currentLines = [];\n                    let i;\n                    for(i = 0; i < lines.length; i++){\n                        // get lines up to a continuation\n                        if (this.rules.other.blockquoteStart.test(lines[i])) {\n                            currentLines.push(lines[i]);\n                            inBlockquote = true;\n                        } else if (!inBlockquote) currentLines.push(lines[i]);\n                        else break;\n                    }\n                    lines = lines.slice(i);\n                    const currentRaw = currentLines.join('\\n');\n                    const currentText = currentRaw// precede setext continuation with 4 spaces so it isn't a setext\n                    .replace(this.rules.other.blockquoteSetextReplace, '\\n    $1').replace(this.rules.other.blockquoteSetextReplace2, '');\n                    raw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n                    text = text ? `${text}\\n${currentText}` : currentText;\n                    // parse blockquote lines as top level tokens\n                    // merge paragraphs if this is a continuation\n                    const top = this.lexer.state.top;\n                    this.lexer.state.top = true;\n                    this.lexer.blockTokens(currentText, tokens, true);\n                    this.lexer.state.top = top;\n                    // if there is no continuation then we are done\n                    if (lines.length === 0) break;\n                    const lastToken = tokens.at(-1);\n                    if (lastToken?.type === 'code') break;\n                    else if (lastToken?.type === 'blockquote') {\n                        // include continuation in nested blockquote\n                        const oldToken = lastToken;\n                        const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                        const newToken = this.blockquote(newText);\n                        tokens[tokens.length - 1] = newToken;\n                        raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n                        text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n                        break;\n                    } else if (lastToken?.type === 'list') {\n                        // include continuation in nested list\n                        const oldToken = lastToken;\n                        const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                        const newToken = this.list(newText);\n                        tokens[tokens.length - 1] = newToken;\n                        raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n                        text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n                        lines = newText.substring(tokens.at(-1).raw.length).split('\\n');\n                        continue;\n                    }\n                }\n                return {\n                    type: 'blockquote',\n                    raw: raw,\n                    tokens: tokens,\n                    text: text\n                };\n            }\n        }\n        list(src) {\n            let cap = this.rules.block.list.exec(src);\n            if (cap) {\n                let bull = cap[1].trim();\n                const isordered = bull.length > 1;\n                const list = {\n                    type: 'list',\n                    raw: '',\n                    ordered: isordered,\n                    start: isordered ? +bull.slice(0, -1) : '',\n                    loose: false,\n                    items: []\n                };\n                bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n                if (this.options.pedantic) bull = isordered ? bull : '[*+-]';\n                // Get next list item\n                const itemRegex = this.rules.other.listItemRegex(bull);\n                let endsWithBlankLine = false;\n                // Check if current bullet point can start a new List Item\n                while(src){\n                    let endEarly = false;\n                    let raw = '';\n                    let itemContents = '';\n                    if (!(cap = itemRegex.exec(src))) break;\n                    if (this.rules.block.hr.test(src)) break;\n                    raw = cap[0];\n                    src = src.substring(raw.length);\n                    let line = cap[2].split('\\n', 1)[0].replace(this.rules.other.listReplaceTabs, (t)=>' '.repeat(3 * t.length));\n                    let nextLine = src.split('\\n', 1)[0];\n                    let blankLine = !line.trim();\n                    let indent = 0;\n                    if (this.options.pedantic) {\n                        indent = 2;\n                        itemContents = line.trimStart();\n                    } else if (blankLine) indent = cap[1].length + 1;\n                    else {\n                        indent = cap[2].search(this.rules.other.nonSpaceChar); // Find first non-space char\n                        indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                        itemContents = line.slice(indent);\n                        indent += cap[1].length;\n                    }\n                    if (blankLine && this.rules.other.blankLine.test(nextLine)) {\n                        raw += nextLine + '\\n';\n                        src = src.substring(nextLine.length + 1);\n                        endEarly = true;\n                    }\n                    if (!endEarly) {\n                        const nextBulletRegex = this.rules.other.nextBulletRegex(indent);\n                        const hrRegex = this.rules.other.hrRegex(indent);\n                        const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);\n                        const headingBeginRegex = this.rules.other.headingBeginRegex(indent);\n                        const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);\n                        // Check if following lines should be included in List Item\n                        while(src){\n                            const rawLine = src.split('\\n', 1)[0];\n                            let nextLineWithoutTabs;\n                            nextLine = rawLine;\n                            // Re-align to follow commonmark nesting rules\n                            if (this.options.pedantic) {\n                                nextLine = nextLine.replace(this.rules.other.listReplaceNesting, '  ');\n                                nextLineWithoutTabs = nextLine;\n                            } else nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, '    ');\n                            // End list item if found code fences\n                            if (fencesBeginRegex.test(nextLine)) break;\n                            // End list item if found start of new heading\n                            if (headingBeginRegex.test(nextLine)) break;\n                            // End list item if found start of html block\n                            if (htmlBeginRegex.test(nextLine)) break;\n                            // End list item if found start of new bullet\n                            if (nextBulletRegex.test(nextLine)) break;\n                            // Horizontal rule found\n                            if (hrRegex.test(nextLine)) break;\n                            if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) itemContents += '\\n' + nextLineWithoutTabs.slice(indent);\n                            else {\n                                // not enough indentation\n                                if (blankLine) break;\n                                // paragraph continuation unless last line was a different block level element\n                                if (line.replace(this.rules.other.tabCharGlobal, '    ').search(this.rules.other.nonSpaceChar) >= 4) break;\n                                if (fencesBeginRegex.test(line)) break;\n                                if (headingBeginRegex.test(line)) break;\n                                if (hrRegex.test(line)) break;\n                                itemContents += '\\n' + nextLine;\n                            }\n                            if (!blankLine && !nextLine.trim()) blankLine = true;\n                            raw += rawLine + '\\n';\n                            src = src.substring(rawLine.length + 1);\n                            line = nextLineWithoutTabs.slice(indent);\n                        }\n                    }\n                    if (!list.loose) {\n                        // If the previous item ended with a blank line, the list is loose\n                        if (endsWithBlankLine) list.loose = true;\n                        else if (this.rules.other.doubleBlankLine.test(raw)) endsWithBlankLine = true;\n                    }\n                    let istask = null;\n                    let ischecked;\n                    // Check for task list items\n                    if (this.options.gfm) {\n                        istask = this.rules.other.listIsTask.exec(itemContents);\n                        if (istask) {\n                            ischecked = istask[0] !== '[ ] ';\n                            itemContents = itemContents.replace(this.rules.other.listReplaceTask, '');\n                        }\n                    }\n                    list.items.push({\n                        type: 'list_item',\n                        raw: raw,\n                        task: !!istask,\n                        checked: ischecked,\n                        loose: false,\n                        text: itemContents,\n                        tokens: []\n                    });\n                    list.raw += raw;\n                }\n                // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n                const lastItem = list.items.at(-1);\n                if (lastItem) {\n                    lastItem.raw = lastItem.raw.trimEnd();\n                    lastItem.text = lastItem.text.trimEnd();\n                } else // not a list since there were no items\n                return;\n                list.raw = list.raw.trimEnd();\n                // Item child tokens handled here at end because we needed to have the final item to trim it first\n                for(let i = 0; i < list.items.length; i++){\n                    this.lexer.state.top = false;\n                    list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                    if (!list.loose) {\n                        // Check if list should be loose\n                        const spacers = list.items[i].tokens.filter((t)=>t.type === 'space');\n                        const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t)=>this.rules.other.anyLine.test(t.raw));\n                        list.loose = hasMultipleLineBreaks;\n                    }\n                }\n                // Set all items to loose if list is loose\n                if (list.loose) for(let i = 0; i < list.items.length; i++)list.items[i].loose = true;\n                return list;\n            }\n        }\n        html(src) {\n            const cap = this.rules.block.html.exec(src);\n            if (cap) {\n                const token = {\n                    type: 'html',\n                    block: true,\n                    raw: cap[0],\n                    pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n                    text: cap[0]\n                };\n                return token;\n            }\n        }\n        def(src) {\n            const cap = this.rules.block.def.exec(src);\n            if (cap) {\n                const tag = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, ' ');\n                const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n                const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n                return {\n                    type: 'def',\n                    tag: tag,\n                    raw: cap[0],\n                    href: href,\n                    title: title\n                };\n            }\n        }\n        table(src) {\n            const cap = this.rules.block.table.exec(src);\n            if (!cap) return;\n            if (!this.rules.other.tableDelimiter.test(cap[2])) // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n            return;\n            const headers = splitCells(cap[1]);\n            const aligns = cap[2].replace(this.rules.other.tableAlignChars, '').split('|');\n            const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, '').split('\\n') : [];\n            const item = {\n                type: 'table',\n                raw: cap[0],\n                header: [],\n                align: [],\n                rows: []\n            };\n            if (headers.length !== aligns.length) // header and align columns must be equal, rows can be different.\n            return;\n            for (const align of aligns){\n                if (this.rules.other.tableAlignRight.test(align)) item.align.push('right');\n                else if (this.rules.other.tableAlignCenter.test(align)) item.align.push('center');\n                else if (this.rules.other.tableAlignLeft.test(align)) item.align.push('left');\n                else item.align.push(null);\n            }\n            for(let i = 0; i < headers.length; i++)item.header.push({\n                text: headers[i],\n                tokens: this.lexer.inline(headers[i]),\n                header: true,\n                align: item.align[i]\n            });\n            for (const row of rows)item.rows.push(splitCells(row, item.header.length).map((cell, i)=>{\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell),\n                    header: false,\n                    align: item.align[i]\n                };\n            }));\n            return item;\n        }\n        lheading(src) {\n            const cap = this.rules.block.lheading.exec(src);\n            if (cap) return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[2].charAt(0) === '=' ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1])\n            };\n        }\n        paragraph(src) {\n            const cap = this.rules.block.paragraph.exec(src);\n            if (cap) {\n                const text = cap[1].charAt(cap[1].length - 1) === '\\n' ? cap[1].slice(0, -1) : cap[1];\n                return {\n                    type: 'paragraph',\n                    raw: cap[0],\n                    text: text,\n                    tokens: this.lexer.inline(text)\n                };\n            }\n        }\n        text(src) {\n            const cap = this.rules.block.text.exec(src);\n            if (cap) return {\n                type: 'text',\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0])\n            };\n        }\n        escape(src) {\n            const cap = this.rules.inline.escape.exec(src);\n            if (cap) return {\n                type: 'escape',\n                raw: cap[0],\n                text: cap[1]\n            };\n        }\n        tag(src) {\n            const cap = this.rules.inline.tag.exec(src);\n            if (cap) {\n                if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) this.lexer.state.inLink = true;\n                else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) this.lexer.state.inLink = false;\n                if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) this.lexer.state.inRawBlock = true;\n                else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) this.lexer.state.inRawBlock = false;\n                return {\n                    type: 'html',\n                    raw: cap[0],\n                    inLink: this.lexer.state.inLink,\n                    inRawBlock: this.lexer.state.inRawBlock,\n                    block: false,\n                    text: cap[0]\n                };\n            }\n        }\n        link(src) {\n            const cap = this.rules.inline.link.exec(src);\n            if (cap) {\n                const trimmedUrl = cap[2].trim();\n                if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {\n                    // commonmark requires matching angle brackets\n                    if (!this.rules.other.endAngleBracket.test(trimmedUrl)) return;\n                    // ending angle bracket cannot be escaped\n                    const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n                    if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) return;\n                } else {\n                    // find closing parenthesis\n                    const lastParenIndex = findClosingBracket(cap[2], '()');\n                    if (lastParenIndex === -2) // more open parens than closed\n                    return;\n                    if (lastParenIndex > -1) {\n                        const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n                        const linkLen = start + cap[1].length + lastParenIndex;\n                        cap[2] = cap[2].substring(0, lastParenIndex);\n                        cap[0] = cap[0].substring(0, linkLen).trim();\n                        cap[3] = '';\n                    }\n                }\n                let href = cap[2];\n                let title = '';\n                if (this.options.pedantic) {\n                    // split pedantic href and title\n                    const link = this.rules.other.pedanticHrefTitle.exec(href);\n                    if (link) {\n                        href = link[1];\n                        title = link[3];\n                    }\n                } else title = cap[3] ? cap[3].slice(1, -1) : '';\n                href = href.trim();\n                if (this.rules.other.startAngleBracket.test(href)) {\n                    if (this.options.pedantic && !this.rules.other.endAngleBracket.test(trimmedUrl)) // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                    else href = href.slice(1, -1);\n                }\n                return outputLink(cap, {\n                    href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n                    title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title\n                }, cap[0], this.lexer, this.rules);\n            }\n        }\n        reflink(src, links) {\n            let cap;\n            if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n                const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, ' ');\n                const link = links[linkString.toLowerCase()];\n                if (!link) {\n                    const text = cap[0].charAt(0);\n                    return {\n                        type: 'text',\n                        raw: text,\n                        text: text\n                    };\n                }\n                return outputLink(cap, link, cap[0], this.lexer, this.rules);\n            }\n        }\n        emStrong(src, maskedSrc, prevChar = '') {\n            let match = this.rules.inline.emStrongLDelim.exec(src);\n            if (!match) return;\n            // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n            if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric)) return;\n            const nextChar = match[1] || match[2] || '';\n            if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n                // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n                const lLength = [\n                    ...match[0]\n                ].length - 1;\n                let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n                const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n                endReg.lastIndex = 0;\n                // Clip maskedSrc to same section of string as src (move to lexer?)\n                maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n                while((match = endReg.exec(maskedSrc)) != null){\n                    rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                    if (!rDelim) continue; // skip single * in __abc*abc__\n                    rLength = [\n                        ...rDelim\n                    ].length;\n                    if (match[3] || match[4]) {\n                        delimTotal += rLength;\n                        continue;\n                    } else if (match[5] || match[6]) {\n                        if (lLength % 3 && !((lLength + rLength) % 3)) {\n                            midDelimTotal += rLength;\n                            continue; // CommonMark Emphasis Rules 9-10\n                        }\n                    }\n                    delimTotal -= rLength;\n                    if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n                    // Remove extra characters. *a*** -> *a*\n                    rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                    // char length can be >1 for unicode characters;\n                    const lastCharLength = [\n                        ...match[0]\n                    ][0].length;\n                    const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                    // Create `em` if smallest delimiter has odd char count. *a***\n                    if (Math.min(lLength, rLength) % 2) {\n                        const text = raw.slice(1, -1);\n                        return {\n                            type: 'em',\n                            raw: raw,\n                            text: text,\n                            tokens: this.lexer.inlineTokens(text)\n                        };\n                    }\n                    // Create 'strong' if smallest delimiter has even char count. **a***\n                    const text = raw.slice(2, -2);\n                    return {\n                        type: 'strong',\n                        raw: raw,\n                        text: text,\n                        tokens: this.lexer.inlineTokens(text)\n                    };\n                }\n            }\n        }\n        codespan(src) {\n            const cap = this.rules.inline.code.exec(src);\n            if (cap) {\n                let text = cap[2].replace(this.rules.other.newLineCharGlobal, ' ');\n                const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);\n                const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);\n                if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) text = text.substring(1, text.length - 1);\n                return {\n                    type: 'codespan',\n                    raw: cap[0],\n                    text: text\n                };\n            }\n        }\n        br(src) {\n            const cap = this.rules.inline.br.exec(src);\n            if (cap) return {\n                type: 'br',\n                raw: cap[0]\n            };\n        }\n        del(src) {\n            const cap = this.rules.inline.del.exec(src);\n            if (cap) return {\n                type: 'del',\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2])\n            };\n        }\n        autolink(src) {\n            const cap = this.rules.inline.autolink.exec(src);\n            if (cap) {\n                let text, href;\n                if (cap[2] === '@') {\n                    text = cap[1];\n                    href = 'mailto:' + text;\n                } else {\n                    text = cap[1];\n                    href = text;\n                }\n                return {\n                    type: 'link',\n                    raw: cap[0],\n                    text: text,\n                    href: href,\n                    tokens: [\n                        {\n                            type: 'text',\n                            raw: text,\n                            text: text\n                        }\n                    ]\n                };\n            }\n        }\n        url(src) {\n            let cap;\n            if (cap = this.rules.inline.url.exec(src)) {\n                let text, href;\n                if (cap[2] === '@') {\n                    text = cap[0];\n                    href = 'mailto:' + text;\n                } else {\n                    // do extended autolink path validation\n                    let prevCapZero;\n                    do {\n                        prevCapZero = cap[0];\n                        cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n                    }while (prevCapZero !== cap[0]);\n                    text = cap[0];\n                    if (cap[1] === 'www.') href = 'http://' + cap[0];\n                    else href = cap[0];\n                }\n                return {\n                    type: 'link',\n                    raw: cap[0],\n                    text: text,\n                    href: href,\n                    tokens: [\n                        {\n                            type: 'text',\n                            raw: text,\n                            text: text\n                        }\n                    ]\n                };\n            }\n        }\n        inlineText(src) {\n            const cap = this.rules.inline.text.exec(src);\n            if (cap) {\n                const escaped = this.lexer.state.inRawBlock;\n                return {\n                    type: 'text',\n                    raw: cap[0],\n                    text: cap[0],\n                    escaped: escaped\n                };\n            }\n        }\n    }\n    /**\n     * Block Lexer\n     */ class _Lexer {\n        tokens;\n        options;\n        state;\n        tokenizer;\n        inlineQueue;\n        constructor(options){\n            // TokenList cannot be created in one go\n            this.tokens = [];\n            this.tokens.links = Object.create(null);\n            this.options = options || exports1.defaults;\n            this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n            this.tokenizer = this.options.tokenizer;\n            this.tokenizer.options = this.options;\n            this.tokenizer.lexer = this;\n            this.inlineQueue = [];\n            this.state = {\n                inLink: false,\n                inRawBlock: false,\n                top: true\n            };\n            const rules = {\n                other: other,\n                block: block.normal,\n                inline: inline.normal\n            };\n            if (this.options.pedantic) {\n                rules.block = block.pedantic;\n                rules.inline = inline.pedantic;\n            } else if (this.options.gfm) {\n                rules.block = block.gfm;\n                if (this.options.breaks) rules.inline = inline.breaks;\n                else rules.inline = inline.gfm;\n            }\n            this.tokenizer.rules = rules;\n        }\n        /**\n         * Expose Rules\n         */ static get rules() {\n            return {\n                block: block,\n                inline: inline\n            };\n        }\n        /**\n         * Static Lex Method\n         */ static lex(src, options) {\n            const lexer = new _Lexer(options);\n            return lexer.lex(src);\n        }\n        /**\n         * Static Lex Inline Method\n         */ static lexInline(src, options) {\n            const lexer = new _Lexer(options);\n            return lexer.inlineTokens(src);\n        }\n        /**\n         * Preprocessing\n         */ lex(src) {\n            src = src.replace(other.carriageReturn, '\\n');\n            this.blockTokens(src, this.tokens);\n            for(let i = 0; i < this.inlineQueue.length; i++){\n                const next = this.inlineQueue[i];\n                this.inlineTokens(next.src, next.tokens);\n            }\n            this.inlineQueue = [];\n            return this.tokens;\n        }\n        blockTokens(src, tokens = [], lastParagraphClipped = false) {\n            if (this.options.pedantic) src = src.replace(other.tabCharGlobal, '    ').replace(other.spaceLine, '');\n            while(src){\n                let token;\n                if (this.options.extensions?.block?.some((extTokenizer)=>{\n                    if (token = extTokenizer.call({\n                        lexer: this\n                    }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) continue;\n                // newline\n                if (token = this.tokenizer.space(src)) {\n                    src = src.substring(token.raw.length);\n                    const lastToken = tokens.at(-1);\n                    if (token.raw.length === 1 && lastToken !== undefined) // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    lastToken.raw += '\\n';\n                    else tokens.push(token);\n                    continue;\n                }\n                // code\n                if (token = this.tokenizer.code(src)) {\n                    src = src.substring(token.raw.length);\n                    const lastToken = tokens.at(-1);\n                    // An indented code block cannot interrupt a paragraph.\n                    if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n                        lastToken.raw += '\\n' + token.raw;\n                        lastToken.text += '\\n' + token.text;\n                        this.inlineQueue.at(-1).src = lastToken.text;\n                    } else tokens.push(token);\n                    continue;\n                }\n                // fences\n                if (token = this.tokenizer.fences(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // heading\n                if (token = this.tokenizer.heading(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // hr\n                if (token = this.tokenizer.hr(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // blockquote\n                if (token = this.tokenizer.blockquote(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // list\n                if (token = this.tokenizer.list(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // html\n                if (token = this.tokenizer.html(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // def\n                if (token = this.tokenizer.def(src)) {\n                    src = src.substring(token.raw.length);\n                    const lastToken = tokens.at(-1);\n                    if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n                        lastToken.raw += '\\n' + token.raw;\n                        lastToken.text += '\\n' + token.raw;\n                        this.inlineQueue.at(-1).src = lastToken.text;\n                    } else if (!this.tokens.links[token.tag]) this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title\n                    };\n                    continue;\n                }\n                // table (gfm)\n                if (token = this.tokenizer.table(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // lheading\n                if (token = this.tokenizer.lheading(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // top-level paragraph\n                // prevent paragraph consuming extensions by clipping 'src' to extension start\n                let cutSrc = src;\n                if (this.options.extensions?.startBlock) {\n                    let startIndex = Infinity;\n                    const tempSrc = src.slice(1);\n                    let tempStart;\n                    this.options.extensions.startBlock.forEach((getStartIndex)=>{\n                        tempStart = getStartIndex.call({\n                            lexer: this\n                        }, tempSrc);\n                        if (typeof tempStart === 'number' && tempStart >= 0) startIndex = Math.min(startIndex, tempStart);\n                    });\n                    if (startIndex < Infinity && startIndex >= 0) cutSrc = src.substring(0, startIndex + 1);\n                }\n                if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                    const lastToken = tokens.at(-1);\n                    if (lastParagraphClipped && lastToken?.type === 'paragraph') {\n                        lastToken.raw += '\\n' + token.raw;\n                        lastToken.text += '\\n' + token.text;\n                        this.inlineQueue.pop();\n                        this.inlineQueue.at(-1).src = lastToken.text;\n                    } else tokens.push(token);\n                    lastParagraphClipped = cutSrc.length !== src.length;\n                    src = src.substring(token.raw.length);\n                    continue;\n                }\n                // text\n                if (token = this.tokenizer.text(src)) {\n                    src = src.substring(token.raw.length);\n                    const lastToken = tokens.at(-1);\n                    if (lastToken?.type === 'text') {\n                        lastToken.raw += '\\n' + token.raw;\n                        lastToken.text += '\\n' + token.text;\n                        this.inlineQueue.pop();\n                        this.inlineQueue.at(-1).src = lastToken.text;\n                    } else tokens.push(token);\n                    continue;\n                }\n                if (src) {\n                    const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        break;\n                    } else throw new Error(errMsg);\n                }\n            }\n            this.state.top = true;\n            return tokens;\n        }\n        inline(src, tokens = []) {\n            this.inlineQueue.push({\n                src: src,\n                tokens: tokens\n            });\n            return tokens;\n        }\n        /**\n         * Lexing/Compiling\n         */ inlineTokens(src, tokens = []) {\n            // String with links masked to avoid interference with em and strong\n            let maskedSrc = src;\n            let match = null;\n            // Mask out reflinks\n            if (this.tokens.links) {\n                const links = Object.keys(this.tokens.links);\n                if (links.length > 0) {\n                    while((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null)if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                }\n            }\n            // Mask out escaped characters\n            while((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null)maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n            // Mask out other blocks\n            while((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null)maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n            let keepPrevChar = false;\n            let prevChar = '';\n            while(src){\n                if (!keepPrevChar) prevChar = '';\n                keepPrevChar = false;\n                let token;\n                // extensions\n                if (this.options.extensions?.inline?.some((extTokenizer)=>{\n                    if (token = extTokenizer.call({\n                        lexer: this\n                    }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) continue;\n                // escape\n                if (token = this.tokenizer.escape(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // tag\n                if (token = this.tokenizer.tag(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // link\n                if (token = this.tokenizer.link(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // reflink, nolink\n                if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                    src = src.substring(token.raw.length);\n                    const lastToken = tokens.at(-1);\n                    if (token.type === 'text' && lastToken?.type === 'text') {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    } else tokens.push(token);\n                    continue;\n                }\n                // em & strong\n                if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // code\n                if (token = this.tokenizer.codespan(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // br\n                if (token = this.tokenizer.br(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // del (gfm)\n                if (token = this.tokenizer.del(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // autolink\n                if (token = this.tokenizer.autolink(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // url (gfm)\n                if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // text\n                // prevent inlineText consuming extensions by clipping 'src' to extension start\n                let cutSrc = src;\n                if (this.options.extensions?.startInline) {\n                    let startIndex = Infinity;\n                    const tempSrc = src.slice(1);\n                    let tempStart;\n                    this.options.extensions.startInline.forEach((getStartIndex)=>{\n                        tempStart = getStartIndex.call({\n                            lexer: this\n                        }, tempSrc);\n                        if (typeof tempStart === 'number' && tempStart >= 0) startIndex = Math.min(startIndex, tempStart);\n                    });\n                    if (startIndex < Infinity && startIndex >= 0) cutSrc = src.substring(0, startIndex + 1);\n                }\n                if (token = this.tokenizer.inlineText(cutSrc)) {\n                    src = src.substring(token.raw.length);\n                    if (token.raw.slice(-1) !== '_') prevChar = token.raw.slice(-1);\n                    keepPrevChar = true;\n                    const lastToken = tokens.at(-1);\n                    if (lastToken?.type === 'text') {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    } else tokens.push(token);\n                    continue;\n                }\n                if (src) {\n                    const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        break;\n                    } else throw new Error(errMsg);\n                }\n            }\n            return tokens;\n        }\n    }\n    /**\n     * Renderer\n     */ class _Renderer {\n        options;\n        parser;\n        constructor(options){\n            this.options = options || exports1.defaults;\n        }\n        space(token) {\n            return '';\n        }\n        code({ text: text, lang: lang, escaped: escaped }) {\n            const langString = (lang || '').match(other.notSpaceStart)?.[0];\n            const code = text.replace(other.endingNewline, '') + '\\n';\n            if (!langString) return '<pre><code>' + (escaped ? code : escape(code, true)) + '</code></pre>\\n';\n            return '<pre><code class=\"language-' + escape(langString) + '\">' + (escaped ? code : escape(code, true)) + '</code></pre>\\n';\n        }\n        blockquote({ tokens: tokens }) {\n            const body = this.parser.parse(tokens);\n            return `<blockquote>\\n${body}</blockquote>\\n`;\n        }\n        html({ text: text }) {\n            return text;\n        }\n        heading({ tokens: tokens, depth: depth }) {\n            return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n`;\n        }\n        hr(token) {\n            return '<hr>\\n';\n        }\n        list(token) {\n            const ordered = token.ordered;\n            const start = token.start;\n            let body = '';\n            for(let j = 0; j < token.items.length; j++){\n                const item = token.items[j];\n                body += this.listitem(item);\n            }\n            const type = ordered ? 'ol' : 'ul';\n            const startAttr = ordered && start !== 1 ? ' start=\"' + start + '\"' : '';\n            return '<' + type + startAttr + '>\\n' + body + '</' + type + '>\\n';\n        }\n        listitem(item) {\n            let itemBody = '';\n            if (item.task) {\n                const checkbox = this.checkbox({\n                    checked: !!item.checked\n                });\n                if (item.loose) {\n                    if (item.tokens[0]?.type === 'paragraph') {\n                        item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                            item.tokens[0].tokens[0].text = checkbox + ' ' + escape(item.tokens[0].tokens[0].text);\n                            item.tokens[0].tokens[0].escaped = true;\n                        }\n                    } else item.tokens.unshift({\n                        type: 'text',\n                        raw: checkbox + ' ',\n                        text: checkbox + ' ',\n                        escaped: true\n                    });\n                } else itemBody += checkbox + ' ';\n            }\n            itemBody += this.parser.parse(item.tokens, !!item.loose);\n            return `<li>${itemBody}</li>\\n`;\n        }\n        checkbox({ checked: checked }) {\n            return '<input ' + (checked ? 'checked=\"\" ' : '') + 'disabled=\"\" type=\"checkbox\">';\n        }\n        paragraph({ tokens: tokens }) {\n            return `<p>${this.parser.parseInline(tokens)}</p>\\n`;\n        }\n        table(token) {\n            let header = '';\n            // header\n            let cell = '';\n            for(let j = 0; j < token.header.length; j++)cell += this.tablecell(token.header[j]);\n            header += this.tablerow({\n                text: cell\n            });\n            let body = '';\n            for(let j = 0; j < token.rows.length; j++){\n                const row = token.rows[j];\n                cell = '';\n                for(let k = 0; k < row.length; k++)cell += this.tablecell(row[k]);\n                body += this.tablerow({\n                    text: cell\n                });\n            }\n            if (body) body = `<tbody>${body}</tbody>`;\n            return \"<table>\\n<thead>\\n\" + header + '</thead>\\n' + body + '</table>\\n';\n        }\n        tablerow({ text: text }) {\n            return `<tr>\\n${text}</tr>\\n`;\n        }\n        tablecell(token) {\n            const content = this.parser.parseInline(token.tokens);\n            const type = token.header ? 'th' : 'td';\n            const tag = token.align ? `<${type} align=\"${token.align}\">` : `<${type}>`;\n            return tag + content + `</${type}>\\n`;\n        }\n        /**\n         * span level renderer\n         */ strong({ tokens: tokens }) {\n            return `<strong>${this.parser.parseInline(tokens)}</strong>`;\n        }\n        em({ tokens: tokens }) {\n            return `<em>${this.parser.parseInline(tokens)}</em>`;\n        }\n        codespan({ text: text }) {\n            return `<code>${escape(text, true)}</code>`;\n        }\n        br(token) {\n            return '<br>';\n        }\n        del({ tokens: tokens }) {\n            return `<del>${this.parser.parseInline(tokens)}</del>`;\n        }\n        link({ href: href, title: title, tokens: tokens }) {\n            const text = this.parser.parseInline(tokens);\n            const cleanHref = cleanUrl(href);\n            if (cleanHref === null) return text;\n            href = cleanHref;\n            let out = '<a href=\"' + href + '\"';\n            if (title) out += ' title=\"' + escape(title) + '\"';\n            out += '>' + text + '</a>';\n            return out;\n        }\n        image({ href: href, title: title, text: text, tokens: tokens }) {\n            if (tokens) text = this.parser.parseInline(tokens, this.parser.textRenderer);\n            const cleanHref = cleanUrl(href);\n            if (cleanHref === null) return escape(text);\n            href = cleanHref;\n            let out = `<img src=\"${href}\" alt=\"${text}\"`;\n            if (title) out += ` title=\"${escape(title)}\"`;\n            out += '>';\n            return out;\n        }\n        text(token) {\n            return 'tokens' in token && token.tokens ? this.parser.parseInline(token.tokens) : 'escaped' in token && token.escaped ? token.text : escape(token.text);\n        }\n    }\n    /**\n     * TextRenderer\n     * returns only the textual part of the token\n     */ class _TextRenderer {\n        // no need for block level renderers\n        strong({ text: text }) {\n            return text;\n        }\n        em({ text: text }) {\n            return text;\n        }\n        codespan({ text: text }) {\n            return text;\n        }\n        del({ text: text }) {\n            return text;\n        }\n        html({ text: text }) {\n            return text;\n        }\n        text({ text: text }) {\n            return text;\n        }\n        link({ text: text }) {\n            return '' + text;\n        }\n        image({ text: text }) {\n            return '' + text;\n        }\n        br() {\n            return '';\n        }\n    }\n    /**\n     * Parsing & Compiling\n     */ class _Parser {\n        options;\n        renderer;\n        textRenderer;\n        constructor(options){\n            this.options = options || exports1.defaults;\n            this.options.renderer = this.options.renderer || new _Renderer();\n            this.renderer = this.options.renderer;\n            this.renderer.options = this.options;\n            this.renderer.parser = this;\n            this.textRenderer = new _TextRenderer();\n        }\n        /**\n         * Static Parse Method\n         */ static parse(tokens, options) {\n            const parser = new _Parser(options);\n            return parser.parse(tokens);\n        }\n        /**\n         * Static Parse Inline Method\n         */ static parseInline(tokens, options) {\n            const parser = new _Parser(options);\n            return parser.parseInline(tokens);\n        }\n        /**\n         * Parse Loop\n         */ parse(tokens, top = true) {\n            let out = '';\n            for(let i = 0; i < tokens.length; i++){\n                const anyToken = tokens[i];\n                // Run any renderer extensions\n                if (this.options.extensions?.renderers?.[anyToken.type]) {\n                    const genericToken = anyToken;\n                    const ret = this.options.extensions.renderers[genericToken.type].call({\n                        parser: this\n                    }, genericToken);\n                    if (ret !== false || ![\n                        'space',\n                        'hr',\n                        'heading',\n                        'code',\n                        'table',\n                        'blockquote',\n                        'list',\n                        'html',\n                        'paragraph',\n                        'text'\n                    ].includes(genericToken.type)) {\n                        out += ret || '';\n                        continue;\n                    }\n                }\n                const token = anyToken;\n                switch(token.type){\n                    case 'space':\n                        out += this.renderer.space(token);\n                        continue;\n                    case 'hr':\n                        out += this.renderer.hr(token);\n                        continue;\n                    case 'heading':\n                        out += this.renderer.heading(token);\n                        continue;\n                    case 'code':\n                        out += this.renderer.code(token);\n                        continue;\n                    case 'table':\n                        out += this.renderer.table(token);\n                        continue;\n                    case 'blockquote':\n                        out += this.renderer.blockquote(token);\n                        continue;\n                    case 'list':\n                        out += this.renderer.list(token);\n                        continue;\n                    case 'html':\n                        out += this.renderer.html(token);\n                        continue;\n                    case 'paragraph':\n                        out += this.renderer.paragraph(token);\n                        continue;\n                    case 'text':\n                        {\n                            let textToken = token;\n                            let body = this.renderer.text(textToken);\n                            while(i + 1 < tokens.length && tokens[i + 1].type === 'text'){\n                                textToken = tokens[++i];\n                                body += '\\n' + this.renderer.text(textToken);\n                            }\n                            if (top) out += this.renderer.paragraph({\n                                type: 'paragraph',\n                                raw: body,\n                                text: body,\n                                tokens: [\n                                    {\n                                        type: 'text',\n                                        raw: body,\n                                        text: body,\n                                        escaped: true\n                                    }\n                                ]\n                            });\n                            else out += body;\n                            continue;\n                        }\n                    default:\n                        {\n                            const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                            if (this.options.silent) {\n                                console.error(errMsg);\n                                return '';\n                            } else throw new Error(errMsg);\n                        }\n                }\n            }\n            return out;\n        }\n        /**\n         * Parse Inline Tokens\n         */ parseInline(tokens, renderer = this.renderer) {\n            let out = '';\n            for(let i = 0; i < tokens.length; i++){\n                const anyToken = tokens[i];\n                // Run any renderer extensions\n                if (this.options.extensions?.renderers?.[anyToken.type]) {\n                    const ret = this.options.extensions.renderers[anyToken.type].call({\n                        parser: this\n                    }, anyToken);\n                    if (ret !== false || ![\n                        'escape',\n                        'html',\n                        'link',\n                        'image',\n                        'strong',\n                        'em',\n                        'codespan',\n                        'br',\n                        'del',\n                        'text'\n                    ].includes(anyToken.type)) {\n                        out += ret || '';\n                        continue;\n                    }\n                }\n                const token = anyToken;\n                switch(token.type){\n                    case 'escape':\n                        out += renderer.text(token);\n                        break;\n                    case 'html':\n                        out += renderer.html(token);\n                        break;\n                    case 'link':\n                        out += renderer.link(token);\n                        break;\n                    case 'image':\n                        out += renderer.image(token);\n                        break;\n                    case 'strong':\n                        out += renderer.strong(token);\n                        break;\n                    case 'em':\n                        out += renderer.em(token);\n                        break;\n                    case 'codespan':\n                        out += renderer.codespan(token);\n                        break;\n                    case 'br':\n                        out += renderer.br(token);\n                        break;\n                    case 'del':\n                        out += renderer.del(token);\n                        break;\n                    case 'text':\n                        out += renderer.text(token);\n                        break;\n                    default:\n                        {\n                            const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                            if (this.options.silent) {\n                                console.error(errMsg);\n                                return '';\n                            } else throw new Error(errMsg);\n                        }\n                }\n            }\n            return out;\n        }\n    }\n    class _Hooks {\n        options;\n        block;\n        constructor(options){\n            this.options = options || exports1.defaults;\n        }\n        static passThroughHooks = new Set([\n            'preprocess',\n            'postprocess',\n            'processAllTokens'\n        ]);\n        /**\n         * Process markdown before marked\n         */ preprocess(markdown) {\n            return markdown;\n        }\n        /**\n         * Process HTML after marked is finished\n         */ postprocess(html) {\n            return html;\n        }\n        /**\n         * Process all tokens before walk tokens\n         */ processAllTokens(tokens) {\n            return tokens;\n        }\n        /**\n         * Provide function to tokenize markdown\n         */ provideLexer() {\n            return this.block ? _Lexer.lex : _Lexer.lexInline;\n        }\n        /**\n         * Provide function to parse tokens\n         */ provideParser() {\n            return this.block ? _Parser.parse : _Parser.parseInline;\n        }\n    }\n    class Marked {\n        defaults = _getDefaults();\n        options = this.setOptions;\n        parse = this.parseMarkdown(true);\n        parseInline = this.parseMarkdown(false);\n        Parser = _Parser;\n        Renderer = _Renderer;\n        TextRenderer = _TextRenderer;\n        Lexer = _Lexer;\n        Tokenizer = _Tokenizer;\n        Hooks = _Hooks;\n        constructor(...args){\n            this.use(...args);\n        }\n        /**\n         * Run callback for every token\n         */ walkTokens(tokens, callback) {\n            let values = [];\n            for (const token of tokens){\n                values = values.concat(callback.call(this, token));\n                switch(token.type){\n                    case 'table':\n                        {\n                            const tableToken = token;\n                            for (const cell of tableToken.header)values = values.concat(this.walkTokens(cell.tokens, callback));\n                            for (const row of tableToken.rows)for (const cell of row)values = values.concat(this.walkTokens(cell.tokens, callback));\n                            break;\n                        }\n                    case 'list':\n                        {\n                            const listToken = token;\n                            values = values.concat(this.walkTokens(listToken.items, callback));\n                            break;\n                        }\n                    default:\n                        {\n                            const genericToken = token;\n                            if (this.defaults.extensions?.childTokens?.[genericToken.type]) this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens)=>{\n                                const tokens = genericToken[childTokens].flat(Infinity);\n                                values = values.concat(this.walkTokens(tokens, callback));\n                            });\n                            else if (genericToken.tokens) values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                        }\n                }\n            }\n            return values;\n        }\n        use(...args) {\n            const extensions = this.defaults.extensions || {\n                renderers: {},\n                childTokens: {}\n            };\n            args.forEach((pack)=>{\n                // copy options to new object\n                const opts = {\n                    ...pack\n                };\n                // set async to true if it was set to true before\n                opts.async = this.defaults.async || opts.async || false;\n                // ==-- Parse \"addon\" extensions --== //\n                if (pack.extensions) {\n                    pack.extensions.forEach((ext)=>{\n                        if (!ext.name) throw new Error('extension name required');\n                        if ('renderer' in ext) {\n                            const prevRenderer = extensions.renderers[ext.name];\n                            if (prevRenderer) // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function(...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) ret = prevRenderer.apply(this, args);\n                                return ret;\n                            };\n                            else extensions.renderers[ext.name] = ext.renderer;\n                        }\n                        if ('tokenizer' in ext) {\n                            if (!ext.level || ext.level !== 'block' && ext.level !== 'inline') throw new Error(\"extension level must be 'block' or 'inline'\");\n                            const extLevel = extensions[ext.level];\n                            if (extLevel) extLevel.unshift(ext.tokenizer);\n                            else extensions[ext.level] = [\n                                ext.tokenizer\n                            ];\n                            if (ext.start) {\n                                if (ext.level === 'block') {\n                                    if (extensions.startBlock) extensions.startBlock.push(ext.start);\n                                    else extensions.startBlock = [\n                                        ext.start\n                                    ];\n                                } else if (ext.level === 'inline') {\n                                    if (extensions.startInline) extensions.startInline.push(ext.start);\n                                    else extensions.startInline = [\n                                        ext.start\n                                    ];\n                                }\n                            }\n                        }\n                        if ('childTokens' in ext && ext.childTokens) extensions.childTokens[ext.name] = ext.childTokens;\n                    });\n                    opts.extensions = extensions;\n                }\n                // ==-- Parse \"overwrite\" extensions --== //\n                if (pack.renderer) {\n                    const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                    for(const prop in pack.renderer){\n                        if (!(prop in renderer)) throw new Error(`renderer '${prop}' does not exist`);\n                        if ([\n                            'options',\n                            'parser'\n                        ].includes(prop)) continue;\n                        const rendererProp = prop;\n                        const rendererFunc = pack.renderer[rendererProp];\n                        const prevRenderer = renderer[rendererProp];\n                        // Replace renderer with func to run extension, but fall back if false\n                        renderer[rendererProp] = (...args)=>{\n                            let ret = rendererFunc.apply(renderer, args);\n                            if (ret === false) ret = prevRenderer.apply(renderer, args);\n                            return ret || '';\n                        };\n                    }\n                    opts.renderer = renderer;\n                }\n                if (pack.tokenizer) {\n                    const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                    for(const prop in pack.tokenizer){\n                        if (!(prop in tokenizer)) throw new Error(`tokenizer '${prop}' does not exist`);\n                        if ([\n                            'options',\n                            'rules',\n                            'lexer'\n                        ].includes(prop)) continue;\n                        const tokenizerProp = prop;\n                        const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                        const prevTokenizer = tokenizer[tokenizerProp];\n                        // Replace tokenizer with func to run extension, but fall back if false\n                        // @ts-expect-error cannot type tokenizer function dynamically\n                        tokenizer[tokenizerProp] = (...args)=>{\n                            let ret = tokenizerFunc.apply(tokenizer, args);\n                            if (ret === false) ret = prevTokenizer.apply(tokenizer, args);\n                            return ret;\n                        };\n                    }\n                    opts.tokenizer = tokenizer;\n                }\n                // ==-- Parse Hooks extensions --== //\n                if (pack.hooks) {\n                    const hooks = this.defaults.hooks || new _Hooks();\n                    for(const prop in pack.hooks){\n                        if (!(prop in hooks)) throw new Error(`hook '${prop}' does not exist`);\n                        if ([\n                            'options',\n                            'block'\n                        ].includes(prop)) continue;\n                        const hooksProp = prop;\n                        const hooksFunc = pack.hooks[hooksProp];\n                        const prevHook = hooks[hooksProp];\n                        if (_Hooks.passThroughHooks.has(prop)) // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (arg)=>{\n                            if (this.defaults.async) return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret)=>{\n                                return prevHook.call(hooks, ret);\n                            });\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                        else // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (...args)=>{\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) ret = prevHook.apply(hooks, args);\n                            return ret;\n                        };\n                    }\n                    opts.hooks = hooks;\n                }\n                // ==-- Parse WalkTokens extensions --== //\n                if (pack.walkTokens) {\n                    const walkTokens = this.defaults.walkTokens;\n                    const packWalktokens = pack.walkTokens;\n                    opts.walkTokens = function(token) {\n                        let values = [];\n                        values.push(packWalktokens.call(this, token));\n                        if (walkTokens) values = values.concat(walkTokens.call(this, token));\n                        return values;\n                    };\n                }\n                this.defaults = {\n                    ...this.defaults,\n                    ...opts\n                };\n            });\n            return this;\n        }\n        setOptions(opt) {\n            this.defaults = {\n                ...this.defaults,\n                ...opt\n            };\n            return this;\n        }\n        lexer(src, options) {\n            return _Lexer.lex(src, options ?? this.defaults);\n        }\n        parser(tokens, options) {\n            return _Parser.parse(tokens, options ?? this.defaults);\n        }\n        parseMarkdown(blockType) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const parse = (src, options)=>{\n                const origOpt = {\n                    ...options\n                };\n                const opt = {\n                    ...this.defaults,\n                    ...origOpt\n                };\n                const throwError = this.onError(!!opt.silent, !!opt.async);\n                // throw error if an extension set async to true but parse was called with async: false\n                if (this.defaults.async === true && origOpt.async === false) return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));\n                // throw error in case of non string input\n                if (typeof src === 'undefined' || src === null) return throwError(new Error('marked(): input parameter is undefined or null'));\n                if (typeof src !== 'string') return throwError(new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected'));\n                if (opt.hooks) {\n                    opt.hooks.options = opt;\n                    opt.hooks.block = blockType;\n                }\n                const lexer = opt.hooks ? opt.hooks.provideLexer() : blockType ? _Lexer.lex : _Lexer.lexInline;\n                const parser = opt.hooks ? opt.hooks.provideParser() : blockType ? _Parser.parse : _Parser.parseInline;\n                if (opt.async) return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src)=>lexer(src, opt)).then((tokens)=>opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens)=>opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(()=>tokens) : tokens).then((tokens)=>parser(tokens, opt)).then((html)=>opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);\n                try {\n                    if (opt.hooks) src = opt.hooks.preprocess(src);\n                    let tokens = lexer(src, opt);\n                    if (opt.hooks) tokens = opt.hooks.processAllTokens(tokens);\n                    if (opt.walkTokens) this.walkTokens(tokens, opt.walkTokens);\n                    let html = parser(tokens, opt);\n                    if (opt.hooks) html = opt.hooks.postprocess(html);\n                    return html;\n                } catch (e) {\n                    return throwError(e);\n                }\n            };\n            return parse;\n        }\n        onError(silent, async) {\n            return (e)=>{\n                e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n                if (silent) {\n                    const msg = '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';\n                    if (async) return Promise.resolve(msg);\n                    return msg;\n                }\n                if (async) return Promise.reject(e);\n                throw e;\n            };\n        }\n    }\n    const markedInstance = new Marked();\n    function marked(src, opt) {\n        return markedInstance.parse(src, opt);\n    }\n    /**\n     * Sets the default options.\n     *\n     * @param options Hash of options\n     */ marked.options = marked.setOptions = function(options) {\n        markedInstance.setOptions(options);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n    /**\n     * Gets the original marked default options.\n     */ marked.getDefaults = _getDefaults;\n    marked.defaults = exports1.defaults;\n    /**\n     * Use Extension\n     */ marked.use = function(...args) {\n        markedInstance.use(...args);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n    /**\n     * Run callback for every token\n     */ marked.walkTokens = function(tokens, callback) {\n        return markedInstance.walkTokens(tokens, callback);\n    };\n    /**\n     * Compiles markdown to HTML without enclosing `p` tag.\n     *\n     * @param src String of markdown source to be compiled\n     * @param options Hash of options\n     * @return String of compiled HTML\n     */ marked.parseInline = markedInstance.parseInline;\n    /**\n     * Expose\n     */ marked.Parser = _Parser;\n    marked.parser = _Parser.parse;\n    marked.Renderer = _Renderer;\n    marked.TextRenderer = _TextRenderer;\n    marked.Lexer = _Lexer;\n    marked.lexer = _Lexer.lex;\n    marked.Tokenizer = _Tokenizer;\n    marked.Hooks = _Hooks;\n    marked.parse = marked;\n    const options = marked.options;\n    const setOptions = marked.setOptions;\n    const use = marked.use;\n    const walkTokens = marked.walkTokens;\n    const parseInline = marked.parseInline;\n    const parse = marked;\n    const parser = _Parser.parse;\n    const lexer = _Lexer.lex;\n    exports1.Hooks = _Hooks;\n    exports1.Lexer = _Lexer;\n    exports1.Marked = Marked;\n    exports1.Parser = _Parser;\n    exports1.Renderer = _Renderer;\n    exports1.TextRenderer = _TextRenderer;\n    exports1.Tokenizer = _Tokenizer;\n    exports1.getDefaults = _getDefaults;\n    exports1.lexer = lexer;\n    exports1.marked = marked;\n    exports1.options = options;\n    exports1.parse = parse;\n    exports1.parseInline = parseInline;\n    exports1.parser = parser;\n    exports1.setOptions = setOptions;\n    exports1.use = use;\n    exports1.walkTokens = walkTokens;\n});\n\n\nconst $b453c56ec4aeb0a8$var$chatLog = document.getElementById(\"chat-log\");\nconst $b453c56ec4aeb0a8$var$promptInput = document.getElementById(\"prompt-input\");\nconst $b453c56ec4aeb0a8$var$sendButton = document.getElementById(\"send-button\");\nconst $b453c56ec4aeb0a8$var$currentModel = \"gemma3:4b\";\n// Function to fetch data from the Ollama API\nasync function $b453c56ec4aeb0a8$var$getResponse() {\n    const prompt = $b453c56ec4aeb0a8$var$promptInput.value;\n    if (!prompt) return;\n    const response = await fetch(\"http://localhost:11434/api/generate\", {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            model: $b453c56ec4aeb0a8$var$currentModel,\n            prompt: prompt,\n            stream: true\n        })\n    });\n    if (!response.ok || !response.body) {\n        console.error(\"Error fetching response:\", response.status, response.statusText);\n        $b453c56ec4aeb0a8$var$chatLog.innerHTML += `<p>Error: Could not get response.</p>`;\n        return;\n    }\n    const reader = response.body.getReader();\n    const decoder = new TextDecoder();\n    let fullReply = \"\";\n    const userMsg = document.createElement(\"div\");\n    userMsg.innerHTML = `<strong>User:</strong> ${prompt}`;\n    $b453c56ec4aeb0a8$var$chatLog.appendChild(userMsg);\n    const botMsg = document.createElement(\"div\");\n    botMsg.innerHTML = `<strong>Bot:</strong> `;\n    $b453c56ec4aeb0a8$var$chatLog.appendChild(botMsg);\n    while(true){\n        const { value: value, done: done } = await reader.read();\n        if (done) break;\n        const chunk = decoder.decode(value, {\n            stream: true\n        });\n        const lines = chunk.split(\"\\n\").filter((line)=>line.trim() !== \"\");\n        for (const line of lines)try {\n            const data = JSON.parse(line);\n            if (data.response) {\n                fullReply += data.response;\n                botMsg.innerHTML = `<strong>Bot:</strong><br>${(0, $d55025bea272cdc1$exports.marked).parse(fullReply)}`;\n            }\n        } catch (err) {\n            console.error(\"Error parsing JSON chunk:\", err, line);\n        }\n    }\n}\n// Function to display messages in the chat log\nfunction $b453c56ec4aeb0a8$var$displayMessage(sender, message) {\n    const messageElement = document.createElement(\"div\");\n    messageElement.innerHTML = `${sender}: ${message}`;\n    $b453c56ec4aeb0a8$var$chatLog.appendChild(messageElement);\n}\n// Event listener for the Send button\n$b453c56ec4aeb0a8$var$sendButton.addEventListener(\"click\", $b453c56ec4aeb0a8$var$getResponse);\n// Event listener for Enter key in the prompt input\n$b453c56ec4aeb0a8$var$promptInput.addEventListener(\"keyup\", function(event) {\n    if (event.key === \"Enter\") $b453c56ec4aeb0a8$var$getResponse();\n});\n// Function to display current model name\nfunction $b453c56ec4aeb0a8$var$displayCurrentModel() {\n    const modelContainer = document.getElementById(\"model-name\");\n    modelContainer.innerText = $b453c56ec4aeb0a8$var$currentModel;\n}\n$b453c56ec4aeb0a8$var$displayCurrentModel();\n\n\n//# sourceMappingURL=popup.f7223817.js.map\n","import { marked } from \"marked\";\n\nconst chatLog = document.getElementById(\"chat-log\");\nconst promptInput = document.getElementById(\"prompt-input\");\nconst sendButton = document.getElementById(\"send-button\");\nconst currentModel = \"gemma3:4b\";\n\n// Function to fetch data from the Ollama API\nasync function getResponse() {\n    const prompt = promptInput.value;\n    if (!prompt) return;\n\n    const response = await fetch(\"http://localhost:11434/api/generate\", {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n            model: currentModel,\n            prompt: prompt,\n            stream: true,\n        }),\n    });\n\n    if (!response.ok || !response.body) {\n        console.error(\n            \"Error fetching response:\",\n            response.status,\n            response.statusText,\n        );\n        chatLog.innerHTML += `<p>Error: Could not get response.</p>`;\n        return;\n    }\n\n    const reader = response.body.getReader();\n    const decoder = new TextDecoder();\n    let fullReply = \"\";\n\n    const userMsg = document.createElement(\"div\");\n    userMsg.innerHTML = `<strong>User:</strong> ${prompt}`;\n    chatLog.appendChild(userMsg);\n\n    const botMsg = document.createElement(\"div\");\n    botMsg.innerHTML = `<strong>Bot:</strong> `;\n    chatLog.appendChild(botMsg);\n\n    while (true) {\n        const { value, done } = await reader.read();\n        if (done) break;\n\n        const chunk = decoder.decode(value, { stream: true });\n        const lines = chunk.split(\"\\n\").filter((line) => line.trim() !== \"\");\n\n        for (const line of lines) {\n            try {\n                const data = JSON.parse(line);\n                if (data.response) {\n                    fullReply += data.response;\n                    botMsg.innerHTML = `<strong>Bot:</strong><br>${marked.parse(fullReply)}`;\n                }\n            } catch (err) {\n                console.error(\"Error parsing JSON chunk:\", err, line);\n            }\n        }\n    }\n}\n\n// Function to display messages in the chat log\nfunction displayMessage(sender, message) {\n    const messageElement = document.createElement(\"div\");\n    messageElement.innerHTML = `${sender}: ${message}`;\n    chatLog.appendChild(messageElement);\n}\n\n// Event listener for the Send button\nsendButton.addEventListener(\"click\", getResponse);\n\n// Event listener for Enter key in the prompt input\npromptInput.addEventListener(\"keyup\", function (event) {\n    if (event.key === \"Enter\") {\n        getResponse();\n    }\n});\n\n// Function to display current model name\nfunction displayCurrentModel() {\n    const modelContainer = document.getElementById(\"model-name\");\n    modelContainer.innerText = currentModel;\n}\ndisplayCurrentModel();\n","/**\n * marked v15.0.11 - a markdown parser\n * Copyright (c) 2011-2025, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.marked = {}));\n})(this, (function (exports) { 'use strict';\n\n    /**\n     * Gets the original marked default options.\n     */\n    function _getDefaults() {\n        return {\n            async: false,\n            breaks: false,\n            extensions: null,\n            gfm: true,\n            hooks: null,\n            pedantic: false,\n            renderer: null,\n            silent: false,\n            tokenizer: null,\n            walkTokens: null,\n        };\n    }\n    exports.defaults = _getDefaults();\n    function changeDefaults(newDefaults) {\n        exports.defaults = newDefaults;\n    }\n\n    const noopTest = { exec: () => null };\n    function edit(regex, opt = '') {\n        let source = typeof regex === 'string' ? regex : regex.source;\n        const obj = {\n            replace: (name, val) => {\n                let valSource = typeof val === 'string' ? val : val.source;\n                valSource = valSource.replace(other.caret, '$1');\n                source = source.replace(name, valSource);\n                return obj;\n            },\n            getRegex: () => {\n                return new RegExp(source, opt);\n            },\n        };\n        return obj;\n    }\n    const other = {\n        codeRemoveIndent: /^(?: {1,4}| {0,3}\\t)/gm,\n        outputLinkReplace: /\\\\([\\[\\]])/g,\n        indentCodeCompensation: /^(\\s+)(?:```)/,\n        beginningSpace: /^\\s+/,\n        endingHash: /#$/,\n        startingSpaceChar: /^ /,\n        endingSpaceChar: / $/,\n        nonSpaceChar: /[^ ]/,\n        newLineCharGlobal: /\\n/g,\n        tabCharGlobal: /\\t/g,\n        multipleSpaceGlobal: /\\s+/g,\n        blankLine: /^[ \\t]*$/,\n        doubleBlankLine: /\\n[ \\t]*\\n[ \\t]*$/,\n        blockquoteStart: /^ {0,3}>/,\n        blockquoteSetextReplace: /\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g,\n        blockquoteSetextReplace2: /^ {0,3}>[ \\t]?/gm,\n        listReplaceTabs: /^\\t+/,\n        listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,\n        listIsTask: /^\\[[ xX]\\] /,\n        listReplaceTask: /^\\[[ xX]\\] +/,\n        anyLine: /\\n.*\\n/,\n        hrefBrackets: /^<(.*)>$/,\n        tableDelimiter: /[:|]/,\n        tableAlignChars: /^\\||\\| *$/g,\n        tableRowBlankLine: /\\n[ \\t]*$/,\n        tableAlignRight: /^ *-+: *$/,\n        tableAlignCenter: /^ *:-+: *$/,\n        tableAlignLeft: /^ *:-+ *$/,\n        startATag: /^<a /i,\n        endATag: /^<\\/a>/i,\n        startPreScriptTag: /^<(pre|code|kbd|script)(\\s|>)/i,\n        endPreScriptTag: /^<\\/(pre|code|kbd|script)(\\s|>)/i,\n        startAngleBracket: /^</,\n        endAngleBracket: />$/,\n        pedanticHrefTitle: /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/,\n        unicodeAlphaNumeric: /[\\p{L}\\p{N}]/u,\n        escapeTest: /[&<>\"']/,\n        escapeReplace: /[&<>\"']/g,\n        escapeTestNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/,\n        escapeReplaceNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/g,\n        unescapeTest: /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig,\n        caret: /(^|[^\\[])\\^/g,\n        percentDecode: /%25/g,\n        findPipe: /\\|/g,\n        splitPipe: / \\|/,\n        slashPipe: /\\\\\\|/g,\n        carriageReturn: /\\r\\n|\\r/g,\n        spaceLine: /^ +$/gm,\n        notSpaceStart: /^\\S*/,\n        endingNewline: /\\n$/,\n        listItemRegex: (bull) => new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`),\n        nextBulletRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`),\n        hrRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`),\n        fencesBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`),\n        headingBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),\n        htmlBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, 'i'),\n    };\n    /**\n     * Block-Level Grammar\n     */\n    const newline = /^(?:[ \\t]*(?:\\n|$))+/;\n    const blockCode = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/;\n    const fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\n    const hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\n    const heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\n    const bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n    const lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/;\n    const lheading = edit(lheadingCore)\n        .replace(/bull/g, bullet) // lists can interrupt\n        .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n        .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n        .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n        .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n        .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n        .replace(/\\|table/g, '') // table not in commonmark\n        .getRegex();\n    const lheadingGfm = edit(lheadingCore)\n        .replace(/bull/g, bullet) // lists can interrupt\n        .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n        .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n        .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n        .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n        .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n        .replace(/table/g, / {0,3}\\|?(?:[:\\- ]*\\|)+[\\:\\- ]*\\n/) // table can interrupt\n        .getRegex();\n    const _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\n    const blockText = /^[^\\n]+/;\n    const _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\n    const def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/)\n        .replace('label', _blockLabel)\n        .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n        .getRegex();\n    const list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n        .replace(/bull/g, bullet)\n        .getRegex();\n    const _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n        + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n        + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n        + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n        + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n        + '|tr|track|ul';\n    const _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\n    const html = edit('^ {0,3}(?:' // optional indentation\n        + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n        + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n        + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n        + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n        + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n        + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (6)\n        + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) open tag\n        + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) closing tag\n        + ')', 'i')\n        .replace('comment', _comment)\n        .replace('tag', _tag)\n        .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n        .getRegex();\n    const paragraph = edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n        .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n        .replace('|table', '')\n        .replace('blockquote', ' {0,3}>')\n        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n        .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n        .getRegex();\n    const blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n        .replace('paragraph', paragraph)\n        .getRegex();\n    /**\n     * Normal Block Grammar\n     */\n    const blockNormal = {\n        blockquote,\n        code: blockCode,\n        def,\n        fences,\n        heading,\n        hr,\n        html,\n        lheading,\n        list,\n        newline,\n        paragraph,\n        table: noopTest,\n        text: blockText,\n    };\n    /**\n     * GFM Block Grammar\n     */\n    const gfmTable = edit('^ *([^\\\\n ].*)\\\\n' // Header\n        + ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n        + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n        .replace('hr', hr)\n        .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n        .replace('blockquote', ' {0,3}>')\n        .replace('code', '(?: {4}| {0,3}\\t)[^\\\\n]')\n        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n        .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n        .getRegex();\n    const blockGfm = {\n        ...blockNormal,\n        lheading: lheadingGfm,\n        table: gfmTable,\n        paragraph: edit(_paragraph)\n            .replace('hr', hr)\n            .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n            .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n            .replace('table', gfmTable) // interrupt paragraphs with table\n            .replace('blockquote', ' {0,3}>')\n            .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n            .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n            .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n            .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n            .getRegex(),\n    };\n    /**\n     * Pedantic grammar (original John Gruber's loose markdown specification)\n     */\n    const blockPedantic = {\n        ...blockNormal,\n        html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)'\n            + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n            + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n            .replace('comment', _comment)\n            .replace(/tag/g, '(?!(?:'\n            + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n            + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n            + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n            .getRegex(),\n        def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n        heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n        fences: noopTest, // fences not supported\n        lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n        paragraph: edit(_paragraph)\n            .replace('hr', hr)\n            .replace('heading', ' *#{1,6} *[^\\n]')\n            .replace('lheading', lheading)\n            .replace('|table', '')\n            .replace('blockquote', ' {0,3}>')\n            .replace('|fences', '')\n            .replace('|list', '')\n            .replace('|html', '')\n            .replace('|tag', '')\n            .getRegex(),\n    };\n    /**\n     * Inline-Level Grammar\n     */\n    const escape$1 = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\n    const inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\n    const br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\n    const inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n    // list of unicode punctuation marks, plus any missing characters from CommonMark spec\n    const _punctuation = /[\\p{P}\\p{S}]/u;\n    const _punctuationOrSpace = /[\\s\\p{P}\\p{S}]/u;\n    const _notPunctuationOrSpace = /[^\\s\\p{P}\\p{S}]/u;\n    const punctuation = edit(/^((?![*_])punctSpace)/, 'u')\n        .replace(/punctSpace/g, _punctuationOrSpace).getRegex();\n    // GFM allows ~ inside strong and em for strikethrough\n    const _punctuationGfmStrongEm = /(?!~)[\\p{P}\\p{S}]/u;\n    const _punctuationOrSpaceGfmStrongEm = /(?!~)[\\s\\p{P}\\p{S}]/u;\n    const _notPunctuationOrSpaceGfmStrongEm = /(?:[^\\s\\p{P}\\p{S}]|~)/u;\n    // sequences em should skip over [title](link), `code`, <html>\n    const blockSkip = /\\[[^[\\]]*?\\]\\((?:\\\\.|[^\\\\\\(\\)]|\\((?:\\\\.|[^\\\\\\(\\)])*\\))*\\)|`[^`]*?`|<[^<>]*?>/g;\n    const emStrongLDelimCore = /^(?:\\*+(?:((?!\\*)punct)|[^\\s*]))|^_+(?:((?!_)punct)|([^\\s_]))/;\n    const emStrongLDelim = edit(emStrongLDelimCore, 'u')\n        .replace(/punct/g, _punctuation)\n        .getRegex();\n    const emStrongLDelimGfm = edit(emStrongLDelimCore, 'u')\n        .replace(/punct/g, _punctuationGfmStrongEm)\n        .getRegex();\n    const emStrongRDelimAstCore = '^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n        + '|[^*]+(?=[^*])' // Consume to delim\n        + '|(?!\\\\*)punct(\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n        + '|notPunctSpace(\\\\*+)(?!\\\\*)(?=punctSpace|$)' // (2) a***#, a*** can only be a Right Delimiter\n        + '|(?!\\\\*)punctSpace(\\\\*+)(?=notPunctSpace)' // (3) #***a, ***a can only be Left Delimiter\n        + '|[\\\\s](\\\\*+)(?!\\\\*)(?=punct)' // (4) ***# can only be Left Delimiter\n        + '|(?!\\\\*)punct(\\\\*+)(?!\\\\*)(?=punct)' // (5) #***# can be either Left or Right Delimiter\n        + '|notPunctSpace(\\\\*+)(?=notPunctSpace)'; // (6) a***a can be either Left or Right Delimiter\n    const emStrongRDelimAst = edit(emStrongRDelimAstCore, 'gu')\n        .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n        .replace(/punctSpace/g, _punctuationOrSpace)\n        .replace(/punct/g, _punctuation)\n        .getRegex();\n    const emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, 'gu')\n        .replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm)\n        .replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm)\n        .replace(/punct/g, _punctuationGfmStrongEm)\n        .getRegex();\n    // (6) Not allowed for _\n    const emStrongRDelimUnd = edit('^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n        + '|[^_]+(?=[^_])' // Consume to delim\n        + '|(?!_)punct(_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n        + '|notPunctSpace(_+)(?!_)(?=punctSpace|$)' // (2) a___#, a___ can only be a Right Delimiter\n        + '|(?!_)punctSpace(_+)(?=notPunctSpace)' // (3) #___a, ___a can only be Left Delimiter\n        + '|[\\\\s](_+)(?!_)(?=punct)' // (4) ___# can only be Left Delimiter\n        + '|(?!_)punct(_+)(?!_)(?=punct)', 'gu') // (5) #___# can be either Left or Right Delimiter\n        .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n        .replace(/punctSpace/g, _punctuationOrSpace)\n        .replace(/punct/g, _punctuation)\n        .getRegex();\n    const anyPunctuation = edit(/\\\\(punct)/, 'gu')\n        .replace(/punct/g, _punctuation)\n        .getRegex();\n    const autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n        .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n        .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n        .getRegex();\n    const _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\n    const tag = edit('^comment'\n        + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n        + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n        + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n        + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n        + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n        .replace('comment', _inlineComment)\n        .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n        .getRegex();\n    const _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n    const link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:(?:[ \\t]*(?:\\n[ \\t]*)?)(title))?\\s*\\)/)\n        .replace('label', _inlineLabel)\n        .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^ \\t\\n\\x00-\\x1f]*/)\n        .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n        .getRegex();\n    const reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n        .replace('label', _inlineLabel)\n        .replace('ref', _blockLabel)\n        .getRegex();\n    const nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n        .replace('ref', _blockLabel)\n        .getRegex();\n    const reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n        .replace('reflink', reflink)\n        .replace('nolink', nolink)\n        .getRegex();\n    /**\n     * Normal Inline Grammar\n     */\n    const inlineNormal = {\n        _backpedal: noopTest, // only used for GFM url\n        anyPunctuation,\n        autolink,\n        blockSkip,\n        br,\n        code: inlineCode,\n        del: noopTest,\n        emStrongLDelim,\n        emStrongRDelimAst,\n        emStrongRDelimUnd,\n        escape: escape$1,\n        link,\n        nolink,\n        punctuation,\n        reflink,\n        reflinkSearch,\n        tag,\n        text: inlineText,\n        url: noopTest,\n    };\n    /**\n     * Pedantic Inline Grammar\n     */\n    const inlinePedantic = {\n        ...inlineNormal,\n        link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n            .replace('label', _inlineLabel)\n            .getRegex(),\n        reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n            .replace('label', _inlineLabel)\n            .getRegex(),\n    };\n    /**\n     * GFM Inline Grammar\n     */\n    const inlineGfm = {\n        ...inlineNormal,\n        emStrongRDelimAst: emStrongRDelimAstGfm,\n        emStrongLDelim: emStrongLDelimGfm,\n        url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i')\n            .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n            .getRegex(),\n        _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n        del: /^(~~?)(?=[^\\s~])((?:\\\\.|[^\\\\])*?(?:\\\\.|[^\\s~\\\\]))\\1(?=[^~]|$)/,\n        text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/,\n    };\n    /**\n     * GFM + Line Breaks Inline Grammar\n     */\n    const inlineBreaks = {\n        ...inlineGfm,\n        br: edit(br).replace('{2,}', '*').getRegex(),\n        text: edit(inlineGfm.text)\n            .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n            .replace(/\\{2,\\}/g, '*')\n            .getRegex(),\n    };\n    /**\n     * exports\n     */\n    const block = {\n        normal: blockNormal,\n        gfm: blockGfm,\n        pedantic: blockPedantic,\n    };\n    const inline = {\n        normal: inlineNormal,\n        gfm: inlineGfm,\n        breaks: inlineBreaks,\n        pedantic: inlinePedantic,\n    };\n\n    /**\n     * Helpers\n     */\n    const escapeReplacements = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#39;',\n    };\n    const getEscapeReplacement = (ch) => escapeReplacements[ch];\n    function escape(html, encode) {\n        if (encode) {\n            if (other.escapeTest.test(html)) {\n                return html.replace(other.escapeReplace, getEscapeReplacement);\n            }\n        }\n        else {\n            if (other.escapeTestNoEncode.test(html)) {\n                return html.replace(other.escapeReplaceNoEncode, getEscapeReplacement);\n            }\n        }\n        return html;\n    }\n    function cleanUrl(href) {\n        try {\n            href = encodeURI(href).replace(other.percentDecode, '%');\n        }\n        catch {\n            return null;\n        }\n        return href;\n    }\n    function splitCells(tableRow, count) {\n        // ensure that every cell-delimiting pipe has a space\n        // before it to distinguish it from an escaped pipe\n        const row = tableRow.replace(other.findPipe, (match, offset, str) => {\n            let escaped = false;\n            let curr = offset;\n            while (--curr >= 0 && str[curr] === '\\\\')\n                escaped = !escaped;\n            if (escaped) {\n                // odd number of slashes means | is escaped\n                // so we leave it alone\n                return '|';\n            }\n            else {\n                // add space before unescaped |\n                return ' |';\n            }\n        }), cells = row.split(other.splitPipe);\n        let i = 0;\n        // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n        if (!cells[0].trim()) {\n            cells.shift();\n        }\n        if (cells.length > 0 && !cells.at(-1)?.trim()) {\n            cells.pop();\n        }\n        if (count) {\n            if (cells.length > count) {\n                cells.splice(count);\n            }\n            else {\n                while (cells.length < count)\n                    cells.push('');\n            }\n        }\n        for (; i < cells.length; i++) {\n            // leading or trailing whitespace is ignored per the gfm spec\n            cells[i] = cells[i].trim().replace(other.slashPipe, '|');\n        }\n        return cells;\n    }\n    /**\n     * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n     * /c*$/ is vulnerable to REDOS.\n     *\n     * @param str\n     * @param c\n     * @param invert Remove suffix of non-c chars instead. Default falsey.\n     */\n    function rtrim(str, c, invert) {\n        const l = str.length;\n        if (l === 0) {\n            return '';\n        }\n        // Length of suffix matching the invert condition.\n        let suffLen = 0;\n        // Step left until we fail to match the invert condition.\n        while (suffLen < l) {\n            const currChar = str.charAt(l - suffLen - 1);\n            if (currChar === c && true) {\n                suffLen++;\n            }\n            else {\n                break;\n            }\n        }\n        return str.slice(0, l - suffLen);\n    }\n    function findClosingBracket(str, b) {\n        if (str.indexOf(b[1]) === -1) {\n            return -1;\n        }\n        let level = 0;\n        for (let i = 0; i < str.length; i++) {\n            if (str[i] === '\\\\') {\n                i++;\n            }\n            else if (str[i] === b[0]) {\n                level++;\n            }\n            else if (str[i] === b[1]) {\n                level--;\n                if (level < 0) {\n                    return i;\n                }\n            }\n        }\n        if (level > 0) {\n            return -2;\n        }\n        return -1;\n    }\n\n    function outputLink(cap, link, raw, lexer, rules) {\n        const href = link.href;\n        const title = link.title || null;\n        const text = cap[1].replace(rules.other.outputLinkReplace, '$1');\n        lexer.state.inLink = true;\n        const token = {\n            type: cap[0].charAt(0) === '!' ? 'image' : 'link',\n            raw,\n            href,\n            title,\n            text,\n            tokens: lexer.inlineTokens(text),\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    function indentCodeCompensation(raw, text, rules) {\n        const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);\n        if (matchIndentToCode === null) {\n            return text;\n        }\n        const indentToCode = matchIndentToCode[1];\n        return text\n            .split('\\n')\n            .map(node => {\n            const matchIndentInNode = node.match(rules.other.beginningSpace);\n            if (matchIndentInNode === null) {\n                return node;\n            }\n            const [indentInNode] = matchIndentInNode;\n            if (indentInNode.length >= indentToCode.length) {\n                return node.slice(indentToCode.length);\n            }\n            return node;\n        })\n            .join('\\n');\n    }\n    /**\n     * Tokenizer\n     */\n    class _Tokenizer {\n        options;\n        rules; // set by the lexer\n        lexer; // set by the lexer\n        constructor(options) {\n            this.options = options || exports.defaults;\n        }\n        space(src) {\n            const cap = this.rules.block.newline.exec(src);\n            if (cap && cap[0].length > 0) {\n                return {\n                    type: 'space',\n                    raw: cap[0],\n                };\n            }\n        }\n        code(src) {\n            const cap = this.rules.block.code.exec(src);\n            if (cap) {\n                const text = cap[0].replace(this.rules.other.codeRemoveIndent, '');\n                return {\n                    type: 'code',\n                    raw: cap[0],\n                    codeBlockStyle: 'indented',\n                    text: !this.options.pedantic\n                        ? rtrim(text, '\\n')\n                        : text,\n                };\n            }\n        }\n        fences(src) {\n            const cap = this.rules.block.fences.exec(src);\n            if (cap) {\n                const raw = cap[0];\n                const text = indentCodeCompensation(raw, cap[3] || '', this.rules);\n                return {\n                    type: 'code',\n                    raw,\n                    lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n                    text,\n                };\n            }\n        }\n        heading(src) {\n            const cap = this.rules.block.heading.exec(src);\n            if (cap) {\n                let text = cap[2].trim();\n                // remove trailing #s\n                if (this.rules.other.endingHash.test(text)) {\n                    const trimmed = rtrim(text, '#');\n                    if (this.options.pedantic) {\n                        text = trimmed.trim();\n                    }\n                    else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {\n                        // CommonMark requires space before trailing #s\n                        text = trimmed.trim();\n                    }\n                }\n                return {\n                    type: 'heading',\n                    raw: cap[0],\n                    depth: cap[1].length,\n                    text,\n                    tokens: this.lexer.inline(text),\n                };\n            }\n        }\n        hr(src) {\n            const cap = this.rules.block.hr.exec(src);\n            if (cap) {\n                return {\n                    type: 'hr',\n                    raw: rtrim(cap[0], '\\n'),\n                };\n            }\n        }\n        blockquote(src) {\n            const cap = this.rules.block.blockquote.exec(src);\n            if (cap) {\n                let lines = rtrim(cap[0], '\\n').split('\\n');\n                let raw = '';\n                let text = '';\n                const tokens = [];\n                while (lines.length > 0) {\n                    let inBlockquote = false;\n                    const currentLines = [];\n                    let i;\n                    for (i = 0; i < lines.length; i++) {\n                        // get lines up to a continuation\n                        if (this.rules.other.blockquoteStart.test(lines[i])) {\n                            currentLines.push(lines[i]);\n                            inBlockquote = true;\n                        }\n                        else if (!inBlockquote) {\n                            currentLines.push(lines[i]);\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    lines = lines.slice(i);\n                    const currentRaw = currentLines.join('\\n');\n                    const currentText = currentRaw\n                        // precede setext continuation with 4 spaces so it isn't a setext\n                        .replace(this.rules.other.blockquoteSetextReplace, '\\n    $1')\n                        .replace(this.rules.other.blockquoteSetextReplace2, '');\n                    raw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n                    text = text ? `${text}\\n${currentText}` : currentText;\n                    // parse blockquote lines as top level tokens\n                    // merge paragraphs if this is a continuation\n                    const top = this.lexer.state.top;\n                    this.lexer.state.top = true;\n                    this.lexer.blockTokens(currentText, tokens, true);\n                    this.lexer.state.top = top;\n                    // if there is no continuation then we are done\n                    if (lines.length === 0) {\n                        break;\n                    }\n                    const lastToken = tokens.at(-1);\n                    if (lastToken?.type === 'code') {\n                        // blockquote continuation cannot be preceded by a code block\n                        break;\n                    }\n                    else if (lastToken?.type === 'blockquote') {\n                        // include continuation in nested blockquote\n                        const oldToken = lastToken;\n                        const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                        const newToken = this.blockquote(newText);\n                        tokens[tokens.length - 1] = newToken;\n                        raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n                        text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n                        break;\n                    }\n                    else if (lastToken?.type === 'list') {\n                        // include continuation in nested list\n                        const oldToken = lastToken;\n                        const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                        const newToken = this.list(newText);\n                        tokens[tokens.length - 1] = newToken;\n                        raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n                        text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n                        lines = newText.substring(tokens.at(-1).raw.length).split('\\n');\n                        continue;\n                    }\n                }\n                return {\n                    type: 'blockquote',\n                    raw,\n                    tokens,\n                    text,\n                };\n            }\n        }\n        list(src) {\n            let cap = this.rules.block.list.exec(src);\n            if (cap) {\n                let bull = cap[1].trim();\n                const isordered = bull.length > 1;\n                const list = {\n                    type: 'list',\n                    raw: '',\n                    ordered: isordered,\n                    start: isordered ? +bull.slice(0, -1) : '',\n                    loose: false,\n                    items: [],\n                };\n                bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n                if (this.options.pedantic) {\n                    bull = isordered ? bull : '[*+-]';\n                }\n                // Get next list item\n                const itemRegex = this.rules.other.listItemRegex(bull);\n                let endsWithBlankLine = false;\n                // Check if current bullet point can start a new List Item\n                while (src) {\n                    let endEarly = false;\n                    let raw = '';\n                    let itemContents = '';\n                    if (!(cap = itemRegex.exec(src))) {\n                        break;\n                    }\n                    if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n                        break;\n                    }\n                    raw = cap[0];\n                    src = src.substring(raw.length);\n                    let line = cap[2].split('\\n', 1)[0].replace(this.rules.other.listReplaceTabs, (t) => ' '.repeat(3 * t.length));\n                    let nextLine = src.split('\\n', 1)[0];\n                    let blankLine = !line.trim();\n                    let indent = 0;\n                    if (this.options.pedantic) {\n                        indent = 2;\n                        itemContents = line.trimStart();\n                    }\n                    else if (blankLine) {\n                        indent = cap[1].length + 1;\n                    }\n                    else {\n                        indent = cap[2].search(this.rules.other.nonSpaceChar); // Find first non-space char\n                        indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                        itemContents = line.slice(indent);\n                        indent += cap[1].length;\n                    }\n                    if (blankLine && this.rules.other.blankLine.test(nextLine)) { // Items begin with at most one blank line\n                        raw += nextLine + '\\n';\n                        src = src.substring(nextLine.length + 1);\n                        endEarly = true;\n                    }\n                    if (!endEarly) {\n                        const nextBulletRegex = this.rules.other.nextBulletRegex(indent);\n                        const hrRegex = this.rules.other.hrRegex(indent);\n                        const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);\n                        const headingBeginRegex = this.rules.other.headingBeginRegex(indent);\n                        const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);\n                        // Check if following lines should be included in List Item\n                        while (src) {\n                            const rawLine = src.split('\\n', 1)[0];\n                            let nextLineWithoutTabs;\n                            nextLine = rawLine;\n                            // Re-align to follow commonmark nesting rules\n                            if (this.options.pedantic) {\n                                nextLine = nextLine.replace(this.rules.other.listReplaceNesting, '  ');\n                                nextLineWithoutTabs = nextLine;\n                            }\n                            else {\n                                nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, '    ');\n                            }\n                            // End list item if found code fences\n                            if (fencesBeginRegex.test(nextLine)) {\n                                break;\n                            }\n                            // End list item if found start of new heading\n                            if (headingBeginRegex.test(nextLine)) {\n                                break;\n                            }\n                            // End list item if found start of html block\n                            if (htmlBeginRegex.test(nextLine)) {\n                                break;\n                            }\n                            // End list item if found start of new bullet\n                            if (nextBulletRegex.test(nextLine)) {\n                                break;\n                            }\n                            // Horizontal rule found\n                            if (hrRegex.test(nextLine)) {\n                                break;\n                            }\n                            if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) { // Dedent if possible\n                                itemContents += '\\n' + nextLineWithoutTabs.slice(indent);\n                            }\n                            else {\n                                // not enough indentation\n                                if (blankLine) {\n                                    break;\n                                }\n                                // paragraph continuation unless last line was a different block level element\n                                if (line.replace(this.rules.other.tabCharGlobal, '    ').search(this.rules.other.nonSpaceChar) >= 4) { // indented code block\n                                    break;\n                                }\n                                if (fencesBeginRegex.test(line)) {\n                                    break;\n                                }\n                                if (headingBeginRegex.test(line)) {\n                                    break;\n                                }\n                                if (hrRegex.test(line)) {\n                                    break;\n                                }\n                                itemContents += '\\n' + nextLine;\n                            }\n                            if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n                                blankLine = true;\n                            }\n                            raw += rawLine + '\\n';\n                            src = src.substring(rawLine.length + 1);\n                            line = nextLineWithoutTabs.slice(indent);\n                        }\n                    }\n                    if (!list.loose) {\n                        // If the previous item ended with a blank line, the list is loose\n                        if (endsWithBlankLine) {\n                            list.loose = true;\n                        }\n                        else if (this.rules.other.doubleBlankLine.test(raw)) {\n                            endsWithBlankLine = true;\n                        }\n                    }\n                    let istask = null;\n                    let ischecked;\n                    // Check for task list items\n                    if (this.options.gfm) {\n                        istask = this.rules.other.listIsTask.exec(itemContents);\n                        if (istask) {\n                            ischecked = istask[0] !== '[ ] ';\n                            itemContents = itemContents.replace(this.rules.other.listReplaceTask, '');\n                        }\n                    }\n                    list.items.push({\n                        type: 'list_item',\n                        raw,\n                        task: !!istask,\n                        checked: ischecked,\n                        loose: false,\n                        text: itemContents,\n                        tokens: [],\n                    });\n                    list.raw += raw;\n                }\n                // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n                const lastItem = list.items.at(-1);\n                if (lastItem) {\n                    lastItem.raw = lastItem.raw.trimEnd();\n                    lastItem.text = lastItem.text.trimEnd();\n                }\n                else {\n                    // not a list since there were no items\n                    return;\n                }\n                list.raw = list.raw.trimEnd();\n                // Item child tokens handled here at end because we needed to have the final item to trim it first\n                for (let i = 0; i < list.items.length; i++) {\n                    this.lexer.state.top = false;\n                    list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                    if (!list.loose) {\n                        // Check if list should be loose\n                        const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n                        const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => this.rules.other.anyLine.test(t.raw));\n                        list.loose = hasMultipleLineBreaks;\n                    }\n                }\n                // Set all items to loose if list is loose\n                if (list.loose) {\n                    for (let i = 0; i < list.items.length; i++) {\n                        list.items[i].loose = true;\n                    }\n                }\n                return list;\n            }\n        }\n        html(src) {\n            const cap = this.rules.block.html.exec(src);\n            if (cap) {\n                const token = {\n                    type: 'html',\n                    block: true,\n                    raw: cap[0],\n                    pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n                    text: cap[0],\n                };\n                return token;\n            }\n        }\n        def(src) {\n            const cap = this.rules.block.def.exec(src);\n            if (cap) {\n                const tag = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, ' ');\n                const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n                const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n                return {\n                    type: 'def',\n                    tag,\n                    raw: cap[0],\n                    href,\n                    title,\n                };\n            }\n        }\n        table(src) {\n            const cap = this.rules.block.table.exec(src);\n            if (!cap) {\n                return;\n            }\n            if (!this.rules.other.tableDelimiter.test(cap[2])) {\n                // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n                return;\n            }\n            const headers = splitCells(cap[1]);\n            const aligns = cap[2].replace(this.rules.other.tableAlignChars, '').split('|');\n            const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, '').split('\\n') : [];\n            const item = {\n                type: 'table',\n                raw: cap[0],\n                header: [],\n                align: [],\n                rows: [],\n            };\n            if (headers.length !== aligns.length) {\n                // header and align columns must be equal, rows can be different.\n                return;\n            }\n            for (const align of aligns) {\n                if (this.rules.other.tableAlignRight.test(align)) {\n                    item.align.push('right');\n                }\n                else if (this.rules.other.tableAlignCenter.test(align)) {\n                    item.align.push('center');\n                }\n                else if (this.rules.other.tableAlignLeft.test(align)) {\n                    item.align.push('left');\n                }\n                else {\n                    item.align.push(null);\n                }\n            }\n            for (let i = 0; i < headers.length; i++) {\n                item.header.push({\n                    text: headers[i],\n                    tokens: this.lexer.inline(headers[i]),\n                    header: true,\n                    align: item.align[i],\n                });\n            }\n            for (const row of rows) {\n                item.rows.push(splitCells(row, item.header.length).map((cell, i) => {\n                    return {\n                        text: cell,\n                        tokens: this.lexer.inline(cell),\n                        header: false,\n                        align: item.align[i],\n                    };\n                }));\n            }\n            return item;\n        }\n        lheading(src) {\n            const cap = this.rules.block.lheading.exec(src);\n            if (cap) {\n                return {\n                    type: 'heading',\n                    raw: cap[0],\n                    depth: cap[2].charAt(0) === '=' ? 1 : 2,\n                    text: cap[1],\n                    tokens: this.lexer.inline(cap[1]),\n                };\n            }\n        }\n        paragraph(src) {\n            const cap = this.rules.block.paragraph.exec(src);\n            if (cap) {\n                const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n                    ? cap[1].slice(0, -1)\n                    : cap[1];\n                return {\n                    type: 'paragraph',\n                    raw: cap[0],\n                    text,\n                    tokens: this.lexer.inline(text),\n                };\n            }\n        }\n        text(src) {\n            const cap = this.rules.block.text.exec(src);\n            if (cap) {\n                return {\n                    type: 'text',\n                    raw: cap[0],\n                    text: cap[0],\n                    tokens: this.lexer.inline(cap[0]),\n                };\n            }\n        }\n        escape(src) {\n            const cap = this.rules.inline.escape.exec(src);\n            if (cap) {\n                return {\n                    type: 'escape',\n                    raw: cap[0],\n                    text: cap[1],\n                };\n            }\n        }\n        tag(src) {\n            const cap = this.rules.inline.tag.exec(src);\n            if (cap) {\n                if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {\n                    this.lexer.state.inLink = true;\n                }\n                else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {\n                    this.lexer.state.inLink = false;\n                }\n                if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {\n                    this.lexer.state.inRawBlock = true;\n                }\n                else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {\n                    this.lexer.state.inRawBlock = false;\n                }\n                return {\n                    type: 'html',\n                    raw: cap[0],\n                    inLink: this.lexer.state.inLink,\n                    inRawBlock: this.lexer.state.inRawBlock,\n                    block: false,\n                    text: cap[0],\n                };\n            }\n        }\n        link(src) {\n            const cap = this.rules.inline.link.exec(src);\n            if (cap) {\n                const trimmedUrl = cap[2].trim();\n                if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {\n                    // commonmark requires matching angle brackets\n                    if (!(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n                        return;\n                    }\n                    // ending angle bracket cannot be escaped\n                    const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n                    if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                        return;\n                    }\n                }\n                else {\n                    // find closing parenthesis\n                    const lastParenIndex = findClosingBracket(cap[2], '()');\n                    if (lastParenIndex === -2) {\n                        // more open parens than closed\n                        return;\n                    }\n                    if (lastParenIndex > -1) {\n                        const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n                        const linkLen = start + cap[1].length + lastParenIndex;\n                        cap[2] = cap[2].substring(0, lastParenIndex);\n                        cap[0] = cap[0].substring(0, linkLen).trim();\n                        cap[3] = '';\n                    }\n                }\n                let href = cap[2];\n                let title = '';\n                if (this.options.pedantic) {\n                    // split pedantic href and title\n                    const link = this.rules.other.pedanticHrefTitle.exec(href);\n                    if (link) {\n                        href = link[1];\n                        title = link[3];\n                    }\n                }\n                else {\n                    title = cap[3] ? cap[3].slice(1, -1) : '';\n                }\n                href = href.trim();\n                if (this.rules.other.startAngleBracket.test(href)) {\n                    if (this.options.pedantic && !(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n                        // pedantic allows starting angle bracket without ending angle bracket\n                        href = href.slice(1);\n                    }\n                    else {\n                        href = href.slice(1, -1);\n                    }\n                }\n                return outputLink(cap, {\n                    href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n                    title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,\n                }, cap[0], this.lexer, this.rules);\n            }\n        }\n        reflink(src, links) {\n            let cap;\n            if ((cap = this.rules.inline.reflink.exec(src))\n                || (cap = this.rules.inline.nolink.exec(src))) {\n                const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, ' ');\n                const link = links[linkString.toLowerCase()];\n                if (!link) {\n                    const text = cap[0].charAt(0);\n                    return {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    };\n                }\n                return outputLink(cap, link, cap[0], this.lexer, this.rules);\n            }\n        }\n        emStrong(src, maskedSrc, prevChar = '') {\n            let match = this.rules.inline.emStrongLDelim.exec(src);\n            if (!match)\n                return;\n            // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n            if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric))\n                return;\n            const nextChar = match[1] || match[2] || '';\n            if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n                // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n                const lLength = [...match[0]].length - 1;\n                let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n                const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n                endReg.lastIndex = 0;\n                // Clip maskedSrc to same section of string as src (move to lexer?)\n                maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n                while ((match = endReg.exec(maskedSrc)) != null) {\n                    rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                    if (!rDelim)\n                        continue; // skip single * in __abc*abc__\n                    rLength = [...rDelim].length;\n                    if (match[3] || match[4]) { // found another Left Delim\n                        delimTotal += rLength;\n                        continue;\n                    }\n                    else if (match[5] || match[6]) { // either Left or Right Delim\n                        if (lLength % 3 && !((lLength + rLength) % 3)) {\n                            midDelimTotal += rLength;\n                            continue; // CommonMark Emphasis Rules 9-10\n                        }\n                    }\n                    delimTotal -= rLength;\n                    if (delimTotal > 0)\n                        continue; // Haven't found enough closing delimiters\n                    // Remove extra characters. *a*** -> *a*\n                    rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                    // char length can be >1 for unicode characters;\n                    const lastCharLength = [...match[0]][0].length;\n                    const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                    // Create `em` if smallest delimiter has odd char count. *a***\n                    if (Math.min(lLength, rLength) % 2) {\n                        const text = raw.slice(1, -1);\n                        return {\n                            type: 'em',\n                            raw,\n                            text,\n                            tokens: this.lexer.inlineTokens(text),\n                        };\n                    }\n                    // Create 'strong' if smallest delimiter has even char count. **a***\n                    const text = raw.slice(2, -2);\n                    return {\n                        type: 'strong',\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text),\n                    };\n                }\n            }\n        }\n        codespan(src) {\n            const cap = this.rules.inline.code.exec(src);\n            if (cap) {\n                let text = cap[2].replace(this.rules.other.newLineCharGlobal, ' ');\n                const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);\n                const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);\n                if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                    text = text.substring(1, text.length - 1);\n                }\n                return {\n                    type: 'codespan',\n                    raw: cap[0],\n                    text,\n                };\n            }\n        }\n        br(src) {\n            const cap = this.rules.inline.br.exec(src);\n            if (cap) {\n                return {\n                    type: 'br',\n                    raw: cap[0],\n                };\n            }\n        }\n        del(src) {\n            const cap = this.rules.inline.del.exec(src);\n            if (cap) {\n                return {\n                    type: 'del',\n                    raw: cap[0],\n                    text: cap[2],\n                    tokens: this.lexer.inlineTokens(cap[2]),\n                };\n            }\n        }\n        autolink(src) {\n            const cap = this.rules.inline.autolink.exec(src);\n            if (cap) {\n                let text, href;\n                if (cap[2] === '@') {\n                    text = cap[1];\n                    href = 'mailto:' + text;\n                }\n                else {\n                    text = cap[1];\n                    href = text;\n                }\n                return {\n                    type: 'link',\n                    raw: cap[0],\n                    text,\n                    href,\n                    tokens: [\n                        {\n                            type: 'text',\n                            raw: text,\n                            text,\n                        },\n                    ],\n                };\n            }\n        }\n        url(src) {\n            let cap;\n            if (cap = this.rules.inline.url.exec(src)) {\n                let text, href;\n                if (cap[2] === '@') {\n                    text = cap[0];\n                    href = 'mailto:' + text;\n                }\n                else {\n                    // do extended autolink path validation\n                    let prevCapZero;\n                    do {\n                        prevCapZero = cap[0];\n                        cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n                    } while (prevCapZero !== cap[0]);\n                    text = cap[0];\n                    if (cap[1] === 'www.') {\n                        href = 'http://' + cap[0];\n                    }\n                    else {\n                        href = cap[0];\n                    }\n                }\n                return {\n                    type: 'link',\n                    raw: cap[0],\n                    text,\n                    href,\n                    tokens: [\n                        {\n                            type: 'text',\n                            raw: text,\n                            text,\n                        },\n                    ],\n                };\n            }\n        }\n        inlineText(src) {\n            const cap = this.rules.inline.text.exec(src);\n            if (cap) {\n                const escaped = this.lexer.state.inRawBlock;\n                return {\n                    type: 'text',\n                    raw: cap[0],\n                    text: cap[0],\n                    escaped,\n                };\n            }\n        }\n    }\n\n    /**\n     * Block Lexer\n     */\n    class _Lexer {\n        tokens;\n        options;\n        state;\n        tokenizer;\n        inlineQueue;\n        constructor(options) {\n            // TokenList cannot be created in one go\n            this.tokens = [];\n            this.tokens.links = Object.create(null);\n            this.options = options || exports.defaults;\n            this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n            this.tokenizer = this.options.tokenizer;\n            this.tokenizer.options = this.options;\n            this.tokenizer.lexer = this;\n            this.inlineQueue = [];\n            this.state = {\n                inLink: false,\n                inRawBlock: false,\n                top: true,\n            };\n            const rules = {\n                other,\n                block: block.normal,\n                inline: inline.normal,\n            };\n            if (this.options.pedantic) {\n                rules.block = block.pedantic;\n                rules.inline = inline.pedantic;\n            }\n            else if (this.options.gfm) {\n                rules.block = block.gfm;\n                if (this.options.breaks) {\n                    rules.inline = inline.breaks;\n                }\n                else {\n                    rules.inline = inline.gfm;\n                }\n            }\n            this.tokenizer.rules = rules;\n        }\n        /**\n         * Expose Rules\n         */\n        static get rules() {\n            return {\n                block,\n                inline,\n            };\n        }\n        /**\n         * Static Lex Method\n         */\n        static lex(src, options) {\n            const lexer = new _Lexer(options);\n            return lexer.lex(src);\n        }\n        /**\n         * Static Lex Inline Method\n         */\n        static lexInline(src, options) {\n            const lexer = new _Lexer(options);\n            return lexer.inlineTokens(src);\n        }\n        /**\n         * Preprocessing\n         */\n        lex(src) {\n            src = src.replace(other.carriageReturn, '\\n');\n            this.blockTokens(src, this.tokens);\n            for (let i = 0; i < this.inlineQueue.length; i++) {\n                const next = this.inlineQueue[i];\n                this.inlineTokens(next.src, next.tokens);\n            }\n            this.inlineQueue = [];\n            return this.tokens;\n        }\n        blockTokens(src, tokens = [], lastParagraphClipped = false) {\n            if (this.options.pedantic) {\n                src = src.replace(other.tabCharGlobal, '    ').replace(other.spaceLine, '');\n            }\n            while (src) {\n                let token;\n                if (this.options.extensions?.block?.some((extTokenizer) => {\n                    if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) {\n                    continue;\n                }\n                // newline\n                if (token = this.tokenizer.space(src)) {\n                    src = src.substring(token.raw.length);\n                    const lastToken = tokens.at(-1);\n                    if (token.raw.length === 1 && lastToken !== undefined) {\n                        // if there's a single \\n as a spacer, it's terminating the last line,\n                        // so move it there so that we don't get unnecessary paragraph tags\n                        lastToken.raw += '\\n';\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                // code\n                if (token = this.tokenizer.code(src)) {\n                    src = src.substring(token.raw.length);\n                    const lastToken = tokens.at(-1);\n                    // An indented code block cannot interrupt a paragraph.\n                    if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n                        lastToken.raw += '\\n' + token.raw;\n                        lastToken.text += '\\n' + token.text;\n                        this.inlineQueue.at(-1).src = lastToken.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                // fences\n                if (token = this.tokenizer.fences(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // heading\n                if (token = this.tokenizer.heading(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // hr\n                if (token = this.tokenizer.hr(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // blockquote\n                if (token = this.tokenizer.blockquote(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // list\n                if (token = this.tokenizer.list(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // html\n                if (token = this.tokenizer.html(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // def\n                if (token = this.tokenizer.def(src)) {\n                    src = src.substring(token.raw.length);\n                    const lastToken = tokens.at(-1);\n                    if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n                        lastToken.raw += '\\n' + token.raw;\n                        lastToken.text += '\\n' + token.raw;\n                        this.inlineQueue.at(-1).src = lastToken.text;\n                    }\n                    else if (!this.tokens.links[token.tag]) {\n                        this.tokens.links[token.tag] = {\n                            href: token.href,\n                            title: token.title,\n                        };\n                    }\n                    continue;\n                }\n                // table (gfm)\n                if (token = this.tokenizer.table(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // lheading\n                if (token = this.tokenizer.lheading(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // top-level paragraph\n                // prevent paragraph consuming extensions by clipping 'src' to extension start\n                let cutSrc = src;\n                if (this.options.extensions?.startBlock) {\n                    let startIndex = Infinity;\n                    const tempSrc = src.slice(1);\n                    let tempStart;\n                    this.options.extensions.startBlock.forEach((getStartIndex) => {\n                        tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                        if (typeof tempStart === 'number' && tempStart >= 0) {\n                            startIndex = Math.min(startIndex, tempStart);\n                        }\n                    });\n                    if (startIndex < Infinity && startIndex >= 0) {\n                        cutSrc = src.substring(0, startIndex + 1);\n                    }\n                }\n                if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                    const lastToken = tokens.at(-1);\n                    if (lastParagraphClipped && lastToken?.type === 'paragraph') {\n                        lastToken.raw += '\\n' + token.raw;\n                        lastToken.text += '\\n' + token.text;\n                        this.inlineQueue.pop();\n                        this.inlineQueue.at(-1).src = lastToken.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    lastParagraphClipped = cutSrc.length !== src.length;\n                    src = src.substring(token.raw.length);\n                    continue;\n                }\n                // text\n                if (token = this.tokenizer.text(src)) {\n                    src = src.substring(token.raw.length);\n                    const lastToken = tokens.at(-1);\n                    if (lastToken?.type === 'text') {\n                        lastToken.raw += '\\n' + token.raw;\n                        lastToken.text += '\\n' + token.text;\n                        this.inlineQueue.pop();\n                        this.inlineQueue.at(-1).src = lastToken.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                if (src) {\n                    const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        break;\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n            this.state.top = true;\n            return tokens;\n        }\n        inline(src, tokens = []) {\n            this.inlineQueue.push({ src, tokens });\n            return tokens;\n        }\n        /**\n         * Lexing/Compiling\n         */\n        inlineTokens(src, tokens = []) {\n            // String with links masked to avoid interference with em and strong\n            let maskedSrc = src;\n            let match = null;\n            // Mask out reflinks\n            if (this.tokens.links) {\n                const links = Object.keys(this.tokens.links);\n                if (links.length > 0) {\n                    while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n                        if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n                            maskedSrc = maskedSrc.slice(0, match.index)\n                                + '[' + 'a'.repeat(match[0].length - 2) + ']'\n                                + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                        }\n                    }\n                }\n            }\n            // Mask out escaped characters\n            while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n                maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n            }\n            // Mask out other blocks\n            while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n                maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n            }\n            let keepPrevChar = false;\n            let prevChar = '';\n            while (src) {\n                if (!keepPrevChar) {\n                    prevChar = '';\n                }\n                keepPrevChar = false;\n                let token;\n                // extensions\n                if (this.options.extensions?.inline?.some((extTokenizer) => {\n                    if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) {\n                    continue;\n                }\n                // escape\n                if (token = this.tokenizer.escape(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // tag\n                if (token = this.tokenizer.tag(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // link\n                if (token = this.tokenizer.link(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // reflink, nolink\n                if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                    src = src.substring(token.raw.length);\n                    const lastToken = tokens.at(-1);\n                    if (token.type === 'text' && lastToken?.type === 'text') {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                // em & strong\n                if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // code\n                if (token = this.tokenizer.codespan(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // br\n                if (token = this.tokenizer.br(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // del (gfm)\n                if (token = this.tokenizer.del(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // autolink\n                if (token = this.tokenizer.autolink(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // url (gfm)\n                if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // text\n                // prevent inlineText consuming extensions by clipping 'src' to extension start\n                let cutSrc = src;\n                if (this.options.extensions?.startInline) {\n                    let startIndex = Infinity;\n                    const tempSrc = src.slice(1);\n                    let tempStart;\n                    this.options.extensions.startInline.forEach((getStartIndex) => {\n                        tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                        if (typeof tempStart === 'number' && tempStart >= 0) {\n                            startIndex = Math.min(startIndex, tempStart);\n                        }\n                    });\n                    if (startIndex < Infinity && startIndex >= 0) {\n                        cutSrc = src.substring(0, startIndex + 1);\n                    }\n                }\n                if (token = this.tokenizer.inlineText(cutSrc)) {\n                    src = src.substring(token.raw.length);\n                    if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n                        prevChar = token.raw.slice(-1);\n                    }\n                    keepPrevChar = true;\n                    const lastToken = tokens.at(-1);\n                    if (lastToken?.type === 'text') {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                if (src) {\n                    const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        break;\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n            return tokens;\n        }\n    }\n\n    /**\n     * Renderer\n     */\n    class _Renderer {\n        options;\n        parser; // set by the parser\n        constructor(options) {\n            this.options = options || exports.defaults;\n        }\n        space(token) {\n            return '';\n        }\n        code({ text, lang, escaped }) {\n            const langString = (lang || '').match(other.notSpaceStart)?.[0];\n            const code = text.replace(other.endingNewline, '') + '\\n';\n            if (!langString) {\n                return '<pre><code>'\n                    + (escaped ? code : escape(code, true))\n                    + '</code></pre>\\n';\n            }\n            return '<pre><code class=\"language-'\n                + escape(langString)\n                + '\">'\n                + (escaped ? code : escape(code, true))\n                + '</code></pre>\\n';\n        }\n        blockquote({ tokens }) {\n            const body = this.parser.parse(tokens);\n            return `<blockquote>\\n${body}</blockquote>\\n`;\n        }\n        html({ text }) {\n            return text;\n        }\n        heading({ tokens, depth }) {\n            return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n`;\n        }\n        hr(token) {\n            return '<hr>\\n';\n        }\n        list(token) {\n            const ordered = token.ordered;\n            const start = token.start;\n            let body = '';\n            for (let j = 0; j < token.items.length; j++) {\n                const item = token.items[j];\n                body += this.listitem(item);\n            }\n            const type = ordered ? 'ol' : 'ul';\n            const startAttr = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n            return '<' + type + startAttr + '>\\n' + body + '</' + type + '>\\n';\n        }\n        listitem(item) {\n            let itemBody = '';\n            if (item.task) {\n                const checkbox = this.checkbox({ checked: !!item.checked });\n                if (item.loose) {\n                    if (item.tokens[0]?.type === 'paragraph') {\n                        item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                            item.tokens[0].tokens[0].text = checkbox + ' ' + escape(item.tokens[0].tokens[0].text);\n                            item.tokens[0].tokens[0].escaped = true;\n                        }\n                    }\n                    else {\n                        item.tokens.unshift({\n                            type: 'text',\n                            raw: checkbox + ' ',\n                            text: checkbox + ' ',\n                            escaped: true,\n                        });\n                    }\n                }\n                else {\n                    itemBody += checkbox + ' ';\n                }\n            }\n            itemBody += this.parser.parse(item.tokens, !!item.loose);\n            return `<li>${itemBody}</li>\\n`;\n        }\n        checkbox({ checked }) {\n            return '<input '\n                + (checked ? 'checked=\"\" ' : '')\n                + 'disabled=\"\" type=\"checkbox\">';\n        }\n        paragraph({ tokens }) {\n            return `<p>${this.parser.parseInline(tokens)}</p>\\n`;\n        }\n        table(token) {\n            let header = '';\n            // header\n            let cell = '';\n            for (let j = 0; j < token.header.length; j++) {\n                cell += this.tablecell(token.header[j]);\n            }\n            header += this.tablerow({ text: cell });\n            let body = '';\n            for (let j = 0; j < token.rows.length; j++) {\n                const row = token.rows[j];\n                cell = '';\n                for (let k = 0; k < row.length; k++) {\n                    cell += this.tablecell(row[k]);\n                }\n                body += this.tablerow({ text: cell });\n            }\n            if (body)\n                body = `<tbody>${body}</tbody>`;\n            return '<table>\\n'\n                + '<thead>\\n'\n                + header\n                + '</thead>\\n'\n                + body\n                + '</table>\\n';\n        }\n        tablerow({ text }) {\n            return `<tr>\\n${text}</tr>\\n`;\n        }\n        tablecell(token) {\n            const content = this.parser.parseInline(token.tokens);\n            const type = token.header ? 'th' : 'td';\n            const tag = token.align\n                ? `<${type} align=\"${token.align}\">`\n                : `<${type}>`;\n            return tag + content + `</${type}>\\n`;\n        }\n        /**\n         * span level renderer\n         */\n        strong({ tokens }) {\n            return `<strong>${this.parser.parseInline(tokens)}</strong>`;\n        }\n        em({ tokens }) {\n            return `<em>${this.parser.parseInline(tokens)}</em>`;\n        }\n        codespan({ text }) {\n            return `<code>${escape(text, true)}</code>`;\n        }\n        br(token) {\n            return '<br>';\n        }\n        del({ tokens }) {\n            return `<del>${this.parser.parseInline(tokens)}</del>`;\n        }\n        link({ href, title, tokens }) {\n            const text = this.parser.parseInline(tokens);\n            const cleanHref = cleanUrl(href);\n            if (cleanHref === null) {\n                return text;\n            }\n            href = cleanHref;\n            let out = '<a href=\"' + href + '\"';\n            if (title) {\n                out += ' title=\"' + (escape(title)) + '\"';\n            }\n            out += '>' + text + '</a>';\n            return out;\n        }\n        image({ href, title, text, tokens }) {\n            if (tokens) {\n                text = this.parser.parseInline(tokens, this.parser.textRenderer);\n            }\n            const cleanHref = cleanUrl(href);\n            if (cleanHref === null) {\n                return escape(text);\n            }\n            href = cleanHref;\n            let out = `<img src=\"${href}\" alt=\"${text}\"`;\n            if (title) {\n                out += ` title=\"${escape(title)}\"`;\n            }\n            out += '>';\n            return out;\n        }\n        text(token) {\n            return 'tokens' in token && token.tokens\n                ? this.parser.parseInline(token.tokens)\n                : ('escaped' in token && token.escaped ? token.text : escape(token.text));\n        }\n    }\n\n    /**\n     * TextRenderer\n     * returns only the textual part of the token\n     */\n    class _TextRenderer {\n        // no need for block level renderers\n        strong({ text }) {\n            return text;\n        }\n        em({ text }) {\n            return text;\n        }\n        codespan({ text }) {\n            return text;\n        }\n        del({ text }) {\n            return text;\n        }\n        html({ text }) {\n            return text;\n        }\n        text({ text }) {\n            return text;\n        }\n        link({ text }) {\n            return '' + text;\n        }\n        image({ text }) {\n            return '' + text;\n        }\n        br() {\n            return '';\n        }\n    }\n\n    /**\n     * Parsing & Compiling\n     */\n    class _Parser {\n        options;\n        renderer;\n        textRenderer;\n        constructor(options) {\n            this.options = options || exports.defaults;\n            this.options.renderer = this.options.renderer || new _Renderer();\n            this.renderer = this.options.renderer;\n            this.renderer.options = this.options;\n            this.renderer.parser = this;\n            this.textRenderer = new _TextRenderer();\n        }\n        /**\n         * Static Parse Method\n         */\n        static parse(tokens, options) {\n            const parser = new _Parser(options);\n            return parser.parse(tokens);\n        }\n        /**\n         * Static Parse Inline Method\n         */\n        static parseInline(tokens, options) {\n            const parser = new _Parser(options);\n            return parser.parseInline(tokens);\n        }\n        /**\n         * Parse Loop\n         */\n        parse(tokens, top = true) {\n            let out = '';\n            for (let i = 0; i < tokens.length; i++) {\n                const anyToken = tokens[i];\n                // Run any renderer extensions\n                if (this.options.extensions?.renderers?.[anyToken.type]) {\n                    const genericToken = anyToken;\n                    const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n                    if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {\n                        out += ret || '';\n                        continue;\n                    }\n                }\n                const token = anyToken;\n                switch (token.type) {\n                    case 'space': {\n                        out += this.renderer.space(token);\n                        continue;\n                    }\n                    case 'hr': {\n                        out += this.renderer.hr(token);\n                        continue;\n                    }\n                    case 'heading': {\n                        out += this.renderer.heading(token);\n                        continue;\n                    }\n                    case 'code': {\n                        out += this.renderer.code(token);\n                        continue;\n                    }\n                    case 'table': {\n                        out += this.renderer.table(token);\n                        continue;\n                    }\n                    case 'blockquote': {\n                        out += this.renderer.blockquote(token);\n                        continue;\n                    }\n                    case 'list': {\n                        out += this.renderer.list(token);\n                        continue;\n                    }\n                    case 'html': {\n                        out += this.renderer.html(token);\n                        continue;\n                    }\n                    case 'paragraph': {\n                        out += this.renderer.paragraph(token);\n                        continue;\n                    }\n                    case 'text': {\n                        let textToken = token;\n                        let body = this.renderer.text(textToken);\n                        while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n                            textToken = tokens[++i];\n                            body += '\\n' + this.renderer.text(textToken);\n                        }\n                        if (top) {\n                            out += this.renderer.paragraph({\n                                type: 'paragraph',\n                                raw: body,\n                                text: body,\n                                tokens: [{ type: 'text', raw: body, text: body, escaped: true }],\n                            });\n                        }\n                        else {\n                            out += body;\n                        }\n                        continue;\n                    }\n                    default: {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return '';\n                        }\n                        else {\n                            throw new Error(errMsg);\n                        }\n                    }\n                }\n            }\n            return out;\n        }\n        /**\n         * Parse Inline Tokens\n         */\n        parseInline(tokens, renderer = this.renderer) {\n            let out = '';\n            for (let i = 0; i < tokens.length; i++) {\n                const anyToken = tokens[i];\n                // Run any renderer extensions\n                if (this.options.extensions?.renderers?.[anyToken.type]) {\n                    const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);\n                    if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {\n                        out += ret || '';\n                        continue;\n                    }\n                }\n                const token = anyToken;\n                switch (token.type) {\n                    case 'escape': {\n                        out += renderer.text(token);\n                        break;\n                    }\n                    case 'html': {\n                        out += renderer.html(token);\n                        break;\n                    }\n                    case 'link': {\n                        out += renderer.link(token);\n                        break;\n                    }\n                    case 'image': {\n                        out += renderer.image(token);\n                        break;\n                    }\n                    case 'strong': {\n                        out += renderer.strong(token);\n                        break;\n                    }\n                    case 'em': {\n                        out += renderer.em(token);\n                        break;\n                    }\n                    case 'codespan': {\n                        out += renderer.codespan(token);\n                        break;\n                    }\n                    case 'br': {\n                        out += renderer.br(token);\n                        break;\n                    }\n                    case 'del': {\n                        out += renderer.del(token);\n                        break;\n                    }\n                    case 'text': {\n                        out += renderer.text(token);\n                        break;\n                    }\n                    default: {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return '';\n                        }\n                        else {\n                            throw new Error(errMsg);\n                        }\n                    }\n                }\n            }\n            return out;\n        }\n    }\n\n    class _Hooks {\n        options;\n        block;\n        constructor(options) {\n            this.options = options || exports.defaults;\n        }\n        static passThroughHooks = new Set([\n            'preprocess',\n            'postprocess',\n            'processAllTokens',\n        ]);\n        /**\n         * Process markdown before marked\n         */\n        preprocess(markdown) {\n            return markdown;\n        }\n        /**\n         * Process HTML after marked is finished\n         */\n        postprocess(html) {\n            return html;\n        }\n        /**\n         * Process all tokens before walk tokens\n         */\n        processAllTokens(tokens) {\n            return tokens;\n        }\n        /**\n         * Provide function to tokenize markdown\n         */\n        provideLexer() {\n            return this.block ? _Lexer.lex : _Lexer.lexInline;\n        }\n        /**\n         * Provide function to parse tokens\n         */\n        provideParser() {\n            return this.block ? _Parser.parse : _Parser.parseInline;\n        }\n    }\n\n    class Marked {\n        defaults = _getDefaults();\n        options = this.setOptions;\n        parse = this.parseMarkdown(true);\n        parseInline = this.parseMarkdown(false);\n        Parser = _Parser;\n        Renderer = _Renderer;\n        TextRenderer = _TextRenderer;\n        Lexer = _Lexer;\n        Tokenizer = _Tokenizer;\n        Hooks = _Hooks;\n        constructor(...args) {\n            this.use(...args);\n        }\n        /**\n         * Run callback for every token\n         */\n        walkTokens(tokens, callback) {\n            let values = [];\n            for (const token of tokens) {\n                values = values.concat(callback.call(this, token));\n                switch (token.type) {\n                    case 'table': {\n                        const tableToken = token;\n                        for (const cell of tableToken.header) {\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                        for (const row of tableToken.rows) {\n                            for (const cell of row) {\n                                values = values.concat(this.walkTokens(cell.tokens, callback));\n                            }\n                        }\n                        break;\n                    }\n                    case 'list': {\n                        const listToken = token;\n                        values = values.concat(this.walkTokens(listToken.items, callback));\n                        break;\n                    }\n                    default: {\n                        const genericToken = token;\n                        if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n                                const tokens = genericToken[childTokens].flat(Infinity);\n                                values = values.concat(this.walkTokens(tokens, callback));\n                            });\n                        }\n                        else if (genericToken.tokens) {\n                            values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                        }\n                    }\n                }\n            }\n            return values;\n        }\n        use(...args) {\n            const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };\n            args.forEach((pack) => {\n                // copy options to new object\n                const opts = { ...pack };\n                // set async to true if it was set to true before\n                opts.async = this.defaults.async || opts.async || false;\n                // ==-- Parse \"addon\" extensions --== //\n                if (pack.extensions) {\n                    pack.extensions.forEach((ext) => {\n                        if (!ext.name) {\n                            throw new Error('extension name required');\n                        }\n                        if ('renderer' in ext) { // Renderer extensions\n                            const prevRenderer = extensions.renderers[ext.name];\n                            if (prevRenderer) {\n                                // Replace extension with func to run new extension but fall back if false\n                                extensions.renderers[ext.name] = function (...args) {\n                                    let ret = ext.renderer.apply(this, args);\n                                    if (ret === false) {\n                                        ret = prevRenderer.apply(this, args);\n                                    }\n                                    return ret;\n                                };\n                            }\n                            else {\n                                extensions.renderers[ext.name] = ext.renderer;\n                            }\n                        }\n                        if ('tokenizer' in ext) { // Tokenizer Extensions\n                            if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n                                throw new Error(\"extension level must be 'block' or 'inline'\");\n                            }\n                            const extLevel = extensions[ext.level];\n                            if (extLevel) {\n                                extLevel.unshift(ext.tokenizer);\n                            }\n                            else {\n                                extensions[ext.level] = [ext.tokenizer];\n                            }\n                            if (ext.start) { // Function to check for start of token\n                                if (ext.level === 'block') {\n                                    if (extensions.startBlock) {\n                                        extensions.startBlock.push(ext.start);\n                                    }\n                                    else {\n                                        extensions.startBlock = [ext.start];\n                                    }\n                                }\n                                else if (ext.level === 'inline') {\n                                    if (extensions.startInline) {\n                                        extensions.startInline.push(ext.start);\n                                    }\n                                    else {\n                                        extensions.startInline = [ext.start];\n                                    }\n                                }\n                            }\n                        }\n                        if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n                            extensions.childTokens[ext.name] = ext.childTokens;\n                        }\n                    });\n                    opts.extensions = extensions;\n                }\n                // ==-- Parse \"overwrite\" extensions --== //\n                if (pack.renderer) {\n                    const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                    for (const prop in pack.renderer) {\n                        if (!(prop in renderer)) {\n                            throw new Error(`renderer '${prop}' does not exist`);\n                        }\n                        if (['options', 'parser'].includes(prop)) {\n                            // ignore options property\n                            continue;\n                        }\n                        const rendererProp = prop;\n                        const rendererFunc = pack.renderer[rendererProp];\n                        const prevRenderer = renderer[rendererProp];\n                        // Replace renderer with func to run extension, but fall back if false\n                        renderer[rendererProp] = (...args) => {\n                            let ret = rendererFunc.apply(renderer, args);\n                            if (ret === false) {\n                                ret = prevRenderer.apply(renderer, args);\n                            }\n                            return ret || '';\n                        };\n                    }\n                    opts.renderer = renderer;\n                }\n                if (pack.tokenizer) {\n                    const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                    for (const prop in pack.tokenizer) {\n                        if (!(prop in tokenizer)) {\n                            throw new Error(`tokenizer '${prop}' does not exist`);\n                        }\n                        if (['options', 'rules', 'lexer'].includes(prop)) {\n                            // ignore options, rules, and lexer properties\n                            continue;\n                        }\n                        const tokenizerProp = prop;\n                        const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                        const prevTokenizer = tokenizer[tokenizerProp];\n                        // Replace tokenizer with func to run extension, but fall back if false\n                        // @ts-expect-error cannot type tokenizer function dynamically\n                        tokenizer[tokenizerProp] = (...args) => {\n                            let ret = tokenizerFunc.apply(tokenizer, args);\n                            if (ret === false) {\n                                ret = prevTokenizer.apply(tokenizer, args);\n                            }\n                            return ret;\n                        };\n                    }\n                    opts.tokenizer = tokenizer;\n                }\n                // ==-- Parse Hooks extensions --== //\n                if (pack.hooks) {\n                    const hooks = this.defaults.hooks || new _Hooks();\n                    for (const prop in pack.hooks) {\n                        if (!(prop in hooks)) {\n                            throw new Error(`hook '${prop}' does not exist`);\n                        }\n                        if (['options', 'block'].includes(prop)) {\n                            // ignore options and block properties\n                            continue;\n                        }\n                        const hooksProp = prop;\n                        const hooksFunc = pack.hooks[hooksProp];\n                        const prevHook = hooks[hooksProp];\n                        if (_Hooks.passThroughHooks.has(prop)) {\n                            // @ts-expect-error cannot type hook function dynamically\n                            hooks[hooksProp] = (arg) => {\n                                if (this.defaults.async) {\n                                    return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {\n                                        return prevHook.call(hooks, ret);\n                                    });\n                                }\n                                const ret = hooksFunc.call(hooks, arg);\n                                return prevHook.call(hooks, ret);\n                            };\n                        }\n                        else {\n                            // @ts-expect-error cannot type hook function dynamically\n                            hooks[hooksProp] = (...args) => {\n                                let ret = hooksFunc.apply(hooks, args);\n                                if (ret === false) {\n                                    ret = prevHook.apply(hooks, args);\n                                }\n                                return ret;\n                            };\n                        }\n                    }\n                    opts.hooks = hooks;\n                }\n                // ==-- Parse WalkTokens extensions --== //\n                if (pack.walkTokens) {\n                    const walkTokens = this.defaults.walkTokens;\n                    const packWalktokens = pack.walkTokens;\n                    opts.walkTokens = function (token) {\n                        let values = [];\n                        values.push(packWalktokens.call(this, token));\n                        if (walkTokens) {\n                            values = values.concat(walkTokens.call(this, token));\n                        }\n                        return values;\n                    };\n                }\n                this.defaults = { ...this.defaults, ...opts };\n            });\n            return this;\n        }\n        setOptions(opt) {\n            this.defaults = { ...this.defaults, ...opt };\n            return this;\n        }\n        lexer(src, options) {\n            return _Lexer.lex(src, options ?? this.defaults);\n        }\n        parser(tokens, options) {\n            return _Parser.parse(tokens, options ?? this.defaults);\n        }\n        parseMarkdown(blockType) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const parse = (src, options) => {\n                const origOpt = { ...options };\n                const opt = { ...this.defaults, ...origOpt };\n                const throwError = this.onError(!!opt.silent, !!opt.async);\n                // throw error if an extension set async to true but parse was called with async: false\n                if (this.defaults.async === true && origOpt.async === false) {\n                    return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));\n                }\n                // throw error in case of non string input\n                if (typeof src === 'undefined' || src === null) {\n                    return throwError(new Error('marked(): input parameter is undefined or null'));\n                }\n                if (typeof src !== 'string') {\n                    return throwError(new Error('marked(): input parameter is of type '\n                        + Object.prototype.toString.call(src) + ', string expected'));\n                }\n                if (opt.hooks) {\n                    opt.hooks.options = opt;\n                    opt.hooks.block = blockType;\n                }\n                const lexer = opt.hooks ? opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);\n                const parser = opt.hooks ? opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);\n                if (opt.async) {\n                    return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n                        .then(src => lexer(src, opt))\n                        .then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)\n                        .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)\n                        .then(tokens => parser(tokens, opt))\n                        .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n                        .catch(throwError);\n                }\n                try {\n                    if (opt.hooks) {\n                        src = opt.hooks.preprocess(src);\n                    }\n                    let tokens = lexer(src, opt);\n                    if (opt.hooks) {\n                        tokens = opt.hooks.processAllTokens(tokens);\n                    }\n                    if (opt.walkTokens) {\n                        this.walkTokens(tokens, opt.walkTokens);\n                    }\n                    let html = parser(tokens, opt);\n                    if (opt.hooks) {\n                        html = opt.hooks.postprocess(html);\n                    }\n                    return html;\n                }\n                catch (e) {\n                    return throwError(e);\n                }\n            };\n            return parse;\n        }\n        onError(silent, async) {\n            return (e) => {\n                e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n                if (silent) {\n                    const msg = '<p>An error occurred:</p><pre>'\n                        + escape(e.message + '', true)\n                        + '</pre>';\n                    if (async) {\n                        return Promise.resolve(msg);\n                    }\n                    return msg;\n                }\n                if (async) {\n                    return Promise.reject(e);\n                }\n                throw e;\n            };\n        }\n    }\n\n    const markedInstance = new Marked();\n    function marked(src, opt) {\n        return markedInstance.parse(src, opt);\n    }\n    /**\n     * Sets the default options.\n     *\n     * @param options Hash of options\n     */\n    marked.options =\n        marked.setOptions = function (options) {\n            markedInstance.setOptions(options);\n            marked.defaults = markedInstance.defaults;\n            changeDefaults(marked.defaults);\n            return marked;\n        };\n    /**\n     * Gets the original marked default options.\n     */\n    marked.getDefaults = _getDefaults;\n    marked.defaults = exports.defaults;\n    /**\n     * Use Extension\n     */\n    marked.use = function (...args) {\n        markedInstance.use(...args);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n    /**\n     * Run callback for every token\n     */\n    marked.walkTokens = function (tokens, callback) {\n        return markedInstance.walkTokens(tokens, callback);\n    };\n    /**\n     * Compiles markdown to HTML without enclosing `p` tag.\n     *\n     * @param src String of markdown source to be compiled\n     * @param options Hash of options\n     * @return String of compiled HTML\n     */\n    marked.parseInline = markedInstance.parseInline;\n    /**\n     * Expose\n     */\n    marked.Parser = _Parser;\n    marked.parser = _Parser.parse;\n    marked.Renderer = _Renderer;\n    marked.TextRenderer = _TextRenderer;\n    marked.Lexer = _Lexer;\n    marked.lexer = _Lexer.lex;\n    marked.Tokenizer = _Tokenizer;\n    marked.Hooks = _Hooks;\n    marked.parse = marked;\n    const options = marked.options;\n    const setOptions = marked.setOptions;\n    const use = marked.use;\n    const walkTokens = marked.walkTokens;\n    const parseInline = marked.parseInline;\n    const parse = marked;\n    const parser = _Parser.parse;\n    const lexer = _Lexer.lex;\n\n    exports.Hooks = _Hooks;\n    exports.Lexer = _Lexer;\n    exports.Marked = Marked;\n    exports.Parser = _Parser;\n    exports.Renderer = _Renderer;\n    exports.TextRenderer = _TextRenderer;\n    exports.Tokenizer = _Tokenizer;\n    exports.getDefaults = _getDefaults;\n    exports.lexer = lexer;\n    exports.marked = marked;\n    exports.options = options;\n    exports.parse = parse;\n    exports.parseInline = parseInline;\n    exports.parser = parser;\n    exports.setOptions = setOptions;\n    exports.use = use;\n    exports.walkTokens = walkTokens;\n\n}));\n//# sourceMappingURL=marked.umd.js.map\n","/**\n * Gets the original marked default options.\n */\nexport function _getDefaults() {\n    return {\n        async: false,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        hooks: null,\n        pedantic: false,\n        renderer: null,\n        silent: false,\n        tokenizer: null,\n        walkTokens: null,\n    };\n}\nexport let _defaults = _getDefaults();\nexport function changeDefaults(newDefaults) {\n    _defaults = newDefaults;\n}\n","const noopTest = { exec: () => null };\nfunction edit(regex, opt = '') {\n    let source = typeof regex === 'string' ? regex : regex.source;\n    const obj = {\n        replace: (name, val) => {\n            let valSource = typeof val === 'string' ? val : val.source;\n            valSource = valSource.replace(other.caret, '$1');\n            source = source.replace(name, valSource);\n            return obj;\n        },\n        getRegex: () => {\n            return new RegExp(source, opt);\n        },\n    };\n    return obj;\n}\nexport const other = {\n    codeRemoveIndent: /^(?: {1,4}| {0,3}\\t)/gm,\n    outputLinkReplace: /\\\\([\\[\\]])/g,\n    indentCodeCompensation: /^(\\s+)(?:```)/,\n    beginningSpace: /^\\s+/,\n    endingHash: /#$/,\n    startingSpaceChar: /^ /,\n    endingSpaceChar: / $/,\n    nonSpaceChar: /[^ ]/,\n    newLineCharGlobal: /\\n/g,\n    tabCharGlobal: /\\t/g,\n    multipleSpaceGlobal: /\\s+/g,\n    blankLine: /^[ \\t]*$/,\n    doubleBlankLine: /\\n[ \\t]*\\n[ \\t]*$/,\n    blockquoteStart: /^ {0,3}>/,\n    blockquoteSetextReplace: /\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g,\n    blockquoteSetextReplace2: /^ {0,3}>[ \\t]?/gm,\n    listReplaceTabs: /^\\t+/,\n    listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,\n    listIsTask: /^\\[[ xX]\\] /,\n    listReplaceTask: /^\\[[ xX]\\] +/,\n    anyLine: /\\n.*\\n/,\n    hrefBrackets: /^<(.*)>$/,\n    tableDelimiter: /[:|]/,\n    tableAlignChars: /^\\||\\| *$/g,\n    tableRowBlankLine: /\\n[ \\t]*$/,\n    tableAlignRight: /^ *-+: *$/,\n    tableAlignCenter: /^ *:-+: *$/,\n    tableAlignLeft: /^ *:-+ *$/,\n    startATag: /^<a /i,\n    endATag: /^<\\/a>/i,\n    startPreScriptTag: /^<(pre|code|kbd|script)(\\s|>)/i,\n    endPreScriptTag: /^<\\/(pre|code|kbd|script)(\\s|>)/i,\n    startAngleBracket: /^</,\n    endAngleBracket: />$/,\n    pedanticHrefTitle: /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/,\n    unicodeAlphaNumeric: /[\\p{L}\\p{N}]/u,\n    escapeTest: /[&<>\"']/,\n    escapeReplace: /[&<>\"']/g,\n    escapeTestNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/,\n    escapeReplaceNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/g,\n    unescapeTest: /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig,\n    caret: /(^|[^\\[])\\^/g,\n    percentDecode: /%25/g,\n    findPipe: /\\|/g,\n    splitPipe: / \\|/,\n    slashPipe: /\\\\\\|/g,\n    carriageReturn: /\\r\\n|\\r/g,\n    spaceLine: /^ +$/gm,\n    notSpaceStart: /^\\S*/,\n    endingNewline: /\\n$/,\n    listItemRegex: (bull) => new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`),\n    nextBulletRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`),\n    hrRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`),\n    fencesBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`),\n    headingBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),\n    htmlBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, 'i'),\n};\n/**\n * Block-Level Grammar\n */\nconst newline = /^(?:[ \\t]*(?:\\n|$))+/;\nconst blockCode = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/;\nconst lheading = edit(lheadingCore)\n    .replace(/bull/g, bullet) // lists can interrupt\n    .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n    .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n    .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n    .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n    .replace(/\\|table/g, '') // table not in commonmark\n    .getRegex();\nconst lheadingGfm = edit(lheadingCore)\n    .replace(/bull/g, bullet) // lists can interrupt\n    .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n    .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n    .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n    .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n    .replace(/table/g, / {0,3}\\|?(?:[:\\- ]*\\|)+[\\:\\- ]*\\n/) // table can interrupt\n    .getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/)\n    .replace('label', _blockLabel)\n    .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n    .getRegex();\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n    .replace(/bull/g, bullet)\n    .getRegex();\nconst _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n    + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n    + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n    + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n    + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n    + '|tr|track|ul';\nconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\nconst html = edit('^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) closing tag\n    + ')', 'i')\n    .replace('comment', _comment)\n    .replace('tag', _tag)\n    .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n    .getRegex();\nconst paragraph = edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n    .replace('|table', '')\n    .replace('blockquote', ' {0,3}>')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex();\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n    .replace('paragraph', paragraph)\n    .getRegex();\n/**\n * Normal Block Grammar\n */\nconst blockNormal = {\n    blockquote,\n    code: blockCode,\n    def,\n    fences,\n    heading,\n    hr,\n    html,\n    lheading,\n    list,\n    newline,\n    paragraph,\n    table: noopTest,\n    text: blockText,\n};\n/**\n * GFM Block Grammar\n */\nconst gfmTable = edit('^ *([^\\\\n ].*)\\\\n' // Header\n    + ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('blockquote', ' {0,3}>')\n    .replace('code', '(?: {4}| {0,3}\\t)[^\\\\n]')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n    .getRegex();\nconst blockGfm = {\n    ...blockNormal,\n    lheading: lheadingGfm,\n    table: gfmTable,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n        .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n        .replace('table', gfmTable) // interrupt paragraphs with table\n        .replace('blockquote', ' {0,3}>')\n        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n        .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n        .getRegex(),\n};\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\nconst blockPedantic = {\n    ...blockNormal,\n    html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)'\n        + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n        + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n        .replace('comment', _comment)\n        .replace(/tag/g, '(?!(?:'\n        + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n        + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n        + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n        .getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest, // fences not supported\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' *#{1,6} *[^\\n]')\n        .replace('lheading', lheading)\n        .replace('|table', '')\n        .replace('blockquote', ' {0,3}>')\n        .replace('|fences', '')\n        .replace('|list', '')\n        .replace('|html', '')\n        .replace('|tag', '')\n        .getRegex(),\n};\n/**\n * Inline-Level Grammar\n */\nconst escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = /[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpace = /[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpace = /[^\\s\\p{P}\\p{S}]/u;\nconst punctuation = edit(/^((?![*_])punctSpace)/, 'u')\n    .replace(/punctSpace/g, _punctuationOrSpace).getRegex();\n// GFM allows ~ inside strong and em for strikethrough\nconst _punctuationGfmStrongEm = /(?!~)[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpaceGfmStrongEm = /(?!~)[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpaceGfmStrongEm = /(?:[^\\s\\p{P}\\p{S}]|~)/u;\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = /\\[[^[\\]]*?\\]\\((?:\\\\.|[^\\\\\\(\\)]|\\((?:\\\\.|[^\\\\\\(\\)])*\\))*\\)|`[^`]*?`|<[^<>]*?>/g;\nconst emStrongLDelimCore = /^(?:\\*+(?:((?!\\*)punct)|[^\\s*]))|^_+(?:((?!_)punct)|([^\\s_]))/;\nconst emStrongLDelim = edit(emStrongLDelimCore, 'u')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst emStrongLDelimGfm = edit(emStrongLDelimCore, 'u')\n    .replace(/punct/g, _punctuationGfmStrongEm)\n    .getRegex();\nconst emStrongRDelimAstCore = '^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n    + '|[^*]+(?=[^*])' // Consume to delim\n    + '|(?!\\\\*)punct(\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n    + '|notPunctSpace(\\\\*+)(?!\\\\*)(?=punctSpace|$)' // (2) a***#, a*** can only be a Right Delimiter\n    + '|(?!\\\\*)punctSpace(\\\\*+)(?=notPunctSpace)' // (3) #***a, ***a can only be Left Delimiter\n    + '|[\\\\s](\\\\*+)(?!\\\\*)(?=punct)' // (4) ***# can only be Left Delimiter\n    + '|(?!\\\\*)punct(\\\\*+)(?!\\\\*)(?=punct)' // (5) #***# can be either Left or Right Delimiter\n    + '|notPunctSpace(\\\\*+)(?=notPunctSpace)'; // (6) a***a can be either Left or Right Delimiter\nconst emStrongRDelimAst = edit(emStrongRDelimAstCore, 'gu')\n    .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n    .replace(/punctSpace/g, _punctuationOrSpace)\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, 'gu')\n    .replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm)\n    .replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm)\n    .replace(/punct/g, _punctuationGfmStrongEm)\n    .getRegex();\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit('^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n    + '|[^_]+(?=[^_])' // Consume to delim\n    + '|(?!_)punct(_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n    + '|notPunctSpace(_+)(?!_)(?=punctSpace|$)' // (2) a___#, a___ can only be a Right Delimiter\n    + '|(?!_)punctSpace(_+)(?=notPunctSpace)' // (3) #___a, ___a can only be Left Delimiter\n    + '|[\\\\s](_+)(?!_)(?=punct)' // (4) ___# can only be Left Delimiter\n    + '|(?!_)punct(_+)(?!_)(?=punct)', 'gu') // (5) #___# can be either Left or Right Delimiter\n    .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n    .replace(/punctSpace/g, _punctuationOrSpace)\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst anyPunctuation = edit(/\\\\(punct)/, 'gu')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n    .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n    .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n    .getRegex();\nconst _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\nconst tag = edit('^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n    .replace('comment', _inlineComment)\n    .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n    .getRegex();\nconst _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:(?:[ \\t]*(?:\\n[ \\t]*)?)(title))?\\s*\\)/)\n    .replace('label', _inlineLabel)\n    .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^ \\t\\n\\x00-\\x1f]*/)\n    .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n    .getRegex();\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n    .replace('label', _inlineLabel)\n    .replace('ref', _blockLabel)\n    .getRegex();\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n    .replace('ref', _blockLabel)\n    .getRegex();\nconst reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n    .replace('reflink', reflink)\n    .replace('nolink', nolink)\n    .getRegex();\n/**\n * Normal Inline Grammar\n */\nconst inlineNormal = {\n    _backpedal: noopTest, // only used for GFM url\n    anyPunctuation,\n    autolink,\n    blockSkip,\n    br,\n    code: inlineCode,\n    del: noopTest,\n    emStrongLDelim,\n    emStrongRDelimAst,\n    emStrongRDelimUnd,\n    escape,\n    link,\n    nolink,\n    punctuation,\n    reflink,\n    reflinkSearch,\n    tag,\n    text: inlineText,\n    url: noopTest,\n};\n/**\n * Pedantic Inline Grammar\n */\nconst inlinePedantic = {\n    ...inlineNormal,\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n};\n/**\n * GFM Inline Grammar\n */\nconst inlineGfm = {\n    ...inlineNormal,\n    emStrongRDelimAst: emStrongRDelimAstGfm,\n    emStrongLDelim: emStrongLDelimGfm,\n    url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i')\n        .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n        .getRegex(),\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])((?:\\\\.|[^\\\\])*?(?:\\\\.|[^\\s~\\\\]))\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/,\n};\n/**\n * GFM + Line Breaks Inline Grammar\n */\nconst inlineBreaks = {\n    ...inlineGfm,\n    br: edit(br).replace('{2,}', '*').getRegex(),\n    text: edit(inlineGfm.text)\n        .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n        .replace(/\\{2,\\}/g, '*')\n        .getRegex(),\n};\n/**\n * exports\n */\nexport const block = {\n    normal: blockNormal,\n    gfm: blockGfm,\n    pedantic: blockPedantic,\n};\nexport const inline = {\n    normal: inlineNormal,\n    gfm: inlineGfm,\n    breaks: inlineBreaks,\n    pedantic: inlinePedantic,\n};\n","import { other } from './rules.ts';\n/**\n * Helpers\n */\nconst escapeReplacements = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n};\nconst getEscapeReplacement = (ch) => escapeReplacements[ch];\nexport function escape(html, encode) {\n    if (encode) {\n        if (other.escapeTest.test(html)) {\n            return html.replace(other.escapeReplace, getEscapeReplacement);\n        }\n    }\n    else {\n        if (other.escapeTestNoEncode.test(html)) {\n            return html.replace(other.escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html;\n}\nexport function unescape(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(other.unescapeTest, (_, n) => {\n        n = n.toLowerCase();\n        if (n === 'colon')\n            return ':';\n        if (n.charAt(0) === '#') {\n            return n.charAt(1) === 'x'\n                ? String.fromCharCode(parseInt(n.substring(2), 16))\n                : String.fromCharCode(+n.substring(1));\n        }\n        return '';\n    });\n}\nexport function cleanUrl(href) {\n    try {\n        href = encodeURI(href).replace(other.percentDecode, '%');\n    }\n    catch {\n        return null;\n    }\n    return href;\n}\nexport function splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    const row = tableRow.replace(other.findPipe, (match, offset, str) => {\n        let escaped = false;\n        let curr = offset;\n        while (--curr >= 0 && str[curr] === '\\\\')\n            escaped = !escaped;\n        if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return '|';\n        }\n        else {\n            // add space before unescaped |\n            return ' |';\n        }\n    }), cells = row.split(other.splitPipe);\n    let i = 0;\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells.at(-1)?.trim()) {\n        cells.pop();\n    }\n    if (count) {\n        if (cells.length > count) {\n            cells.splice(count);\n        }\n        else {\n            while (cells.length < count)\n                cells.push('');\n        }\n    }\n    for (; i < cells.length; i++) {\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(other.slashPipe, '|');\n    }\n    return cells;\n}\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */\nexport function rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n        return '';\n    }\n    // Length of suffix matching the invert condition.\n    let suffLen = 0;\n    // Step left until we fail to match the invert condition.\n    while (suffLen < l) {\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && !invert) {\n            suffLen++;\n        }\n        else if (currChar !== c && invert) {\n            suffLen++;\n        }\n        else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nexport function findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    let level = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] === '\\\\') {\n            i++;\n        }\n        else if (str[i] === b[0]) {\n            level++;\n        }\n        else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    if (level > 0) {\n        return -2;\n    }\n    return -1;\n}\n","import { _defaults } from './defaults.ts';\nimport { rtrim, splitCells, findClosingBracket, } from './helpers.ts';\nfunction outputLink(cap, link, raw, lexer, rules) {\n    const href = link.href;\n    const title = link.title || null;\n    const text = cap[1].replace(rules.other.outputLinkReplace, '$1');\n    lexer.state.inLink = true;\n    const token = {\n        type: cap[0].charAt(0) === '!' ? 'image' : 'link',\n        raw,\n        href,\n        title,\n        text,\n        tokens: lexer.inlineTokens(text),\n    };\n    lexer.state.inLink = false;\n    return token;\n}\nfunction indentCodeCompensation(raw, text, rules) {\n    const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text\n        .split('\\n')\n        .map(node => {\n        const matchIndentInNode = node.match(rules.other.beginningSpace);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        const [indentInNode] = matchIndentInNode;\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    })\n        .join('\\n');\n}\n/**\n * Tokenizer\n */\nexport class _Tokenizer {\n    options;\n    rules; // set by the lexer\n    lexer; // set by the lexer\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    space(src) {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: 'space',\n                raw: cap[0],\n            };\n        }\n    }\n    code(src) {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(this.rules.other.codeRemoveIndent, '');\n            return {\n                type: 'code',\n                raw: cap[0],\n                codeBlockStyle: 'indented',\n                text: !this.options.pedantic\n                    ? rtrim(text, '\\n')\n                    : text,\n            };\n        }\n    }\n    fences(src) {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || '', this.rules);\n            return {\n                type: 'code',\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n                text,\n            };\n        }\n    }\n    heading(src) {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n            // remove trailing #s\n            if (this.rules.other.endingHash.test(text)) {\n                const trimmed = rtrim(text, '#');\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                }\n                else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {\n                    // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text),\n            };\n        }\n    }\n    hr(src) {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: 'hr',\n                raw: rtrim(cap[0], '\\n'),\n            };\n        }\n    }\n    blockquote(src) {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            let lines = rtrim(cap[0], '\\n').split('\\n');\n            let raw = '';\n            let text = '';\n            const tokens = [];\n            while (lines.length > 0) {\n                let inBlockquote = false;\n                const currentLines = [];\n                let i;\n                for (i = 0; i < lines.length; i++) {\n                    // get lines up to a continuation\n                    if (this.rules.other.blockquoteStart.test(lines[i])) {\n                        currentLines.push(lines[i]);\n                        inBlockquote = true;\n                    }\n                    else if (!inBlockquote) {\n                        currentLines.push(lines[i]);\n                    }\n                    else {\n                        break;\n                    }\n                }\n                lines = lines.slice(i);\n                const currentRaw = currentLines.join('\\n');\n                const currentText = currentRaw\n                    // precede setext continuation with 4 spaces so it isn't a setext\n                    .replace(this.rules.other.blockquoteSetextReplace, '\\n    $1')\n                    .replace(this.rules.other.blockquoteSetextReplace2, '');\n                raw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n                text = text ? `${text}\\n${currentText}` : currentText;\n                // parse blockquote lines as top level tokens\n                // merge paragraphs if this is a continuation\n                const top = this.lexer.state.top;\n                this.lexer.state.top = true;\n                this.lexer.blockTokens(currentText, tokens, true);\n                this.lexer.state.top = top;\n                // if there is no continuation then we are done\n                if (lines.length === 0) {\n                    break;\n                }\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === 'code') {\n                    // blockquote continuation cannot be preceded by a code block\n                    break;\n                }\n                else if (lastToken?.type === 'blockquote') {\n                    // include continuation in nested blockquote\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                    const newToken = this.blockquote(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n                    break;\n                }\n                else if (lastToken?.type === 'list') {\n                    // include continuation in nested list\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                    const newToken = this.list(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n                    lines = newText.substring(tokens.at(-1).raw.length).split('\\n');\n                    continue;\n                }\n            }\n            return {\n                type: 'blockquote',\n                raw,\n                tokens,\n                text,\n            };\n        }\n    }\n    list(src) {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list = {\n                type: 'list',\n                raw: '',\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : '',\n                loose: false,\n                items: [],\n            };\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n            if (this.options.pedantic) {\n                bull = isordered ? bull : '[*+-]';\n            }\n            // Get next list item\n            const itemRegex = this.rules.other.listItemRegex(bull);\n            let endsWithBlankLine = false;\n            // Check if current bullet point can start a new List Item\n            while (src) {\n                let endEarly = false;\n                let raw = '';\n                let itemContents = '';\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                let line = cap[2].split('\\n', 1)[0].replace(this.rules.other.listReplaceTabs, (t) => ' '.repeat(3 * t.length));\n                let nextLine = src.split('\\n', 1)[0];\n                let blankLine = !line.trim();\n                let indent = 0;\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimStart();\n                }\n                else if (blankLine) {\n                    indent = cap[1].length + 1;\n                }\n                else {\n                    indent = cap[2].search(this.rules.other.nonSpaceChar); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                if (blankLine && this.rules.other.blankLine.test(nextLine)) { // Items begin with at most one blank line\n                    raw += nextLine + '\\n';\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    const nextBulletRegex = this.rules.other.nextBulletRegex(indent);\n                    const hrRegex = this.rules.other.hrRegex(indent);\n                    const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);\n                    const headingBeginRegex = this.rules.other.headingBeginRegex(indent);\n                    const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);\n                    // Check if following lines should be included in List Item\n                    while (src) {\n                        const rawLine = src.split('\\n', 1)[0];\n                        let nextLineWithoutTabs;\n                        nextLine = rawLine;\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(this.rules.other.listReplaceNesting, '  ');\n                            nextLineWithoutTabs = nextLine;\n                        }\n                        else {\n                            nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, '    ');\n                        }\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of html block\n                        if (htmlBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        // Horizontal rule found\n                        if (hrRegex.test(nextLine)) {\n                            break;\n                        }\n                        if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) { // Dedent if possible\n                            itemContents += '\\n' + nextLineWithoutTabs.slice(indent);\n                        }\n                        else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.replace(this.rules.other.tabCharGlobal, '    ').search(this.rules.other.nonSpaceChar) >= 4) { // indented code block\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += '\\n' + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n                            blankLine = true;\n                        }\n                        raw += rawLine + '\\n';\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLineWithoutTabs.slice(indent);\n                    }\n                }\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    }\n                    else if (this.rules.other.doubleBlankLine.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                let istask = null;\n                let ischecked;\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = this.rules.other.listIsTask.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== '[ ] ';\n                        itemContents = itemContents.replace(this.rules.other.listReplaceTask, '');\n                    }\n                }\n                list.items.push({\n                    type: 'list_item',\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents,\n                    tokens: [],\n                });\n                list.raw += raw;\n            }\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n            const lastItem = list.items.at(-1);\n            if (lastItem) {\n                lastItem.raw = lastItem.raw.trimEnd();\n                lastItem.text = lastItem.text.trimEnd();\n            }\n            else {\n                // not a list since there were no items\n                return;\n            }\n            list.raw = list.raw.trimEnd();\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for (let i = 0; i < list.items.length; i++) {\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                if (!list.loose) {\n                    // Check if list should be loose\n                    const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => this.rules.other.anyLine.test(t.raw));\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for (let i = 0; i < list.items.length; i++) {\n                    list.items[i].loose = true;\n                }\n            }\n            return list;\n        }\n    }\n    html(src) {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token = {\n                type: 'html',\n                block: true,\n                raw: cap[0],\n                pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n                text: cap[0],\n            };\n            return token;\n        }\n    }\n    def(src) {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, ' ');\n            const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n            return {\n                type: 'def',\n                tag,\n                raw: cap[0],\n                href,\n                title,\n            };\n        }\n    }\n    table(src) {\n        const cap = this.rules.block.table.exec(src);\n        if (!cap) {\n            return;\n        }\n        if (!this.rules.other.tableDelimiter.test(cap[2])) {\n            // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n            return;\n        }\n        const headers = splitCells(cap[1]);\n        const aligns = cap[2].replace(this.rules.other.tableAlignChars, '').split('|');\n        const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, '').split('\\n') : [];\n        const item = {\n            type: 'table',\n            raw: cap[0],\n            header: [],\n            align: [],\n            rows: [],\n        };\n        if (headers.length !== aligns.length) {\n            // header and align columns must be equal, rows can be different.\n            return;\n        }\n        for (const align of aligns) {\n            if (this.rules.other.tableAlignRight.test(align)) {\n                item.align.push('right');\n            }\n            else if (this.rules.other.tableAlignCenter.test(align)) {\n                item.align.push('center');\n            }\n            else if (this.rules.other.tableAlignLeft.test(align)) {\n                item.align.push('left');\n            }\n            else {\n                item.align.push(null);\n            }\n        }\n        for (let i = 0; i < headers.length; i++) {\n            item.header.push({\n                text: headers[i],\n                tokens: this.lexer.inline(headers[i]),\n                header: true,\n                align: item.align[i],\n            });\n        }\n        for (const row of rows) {\n            item.rows.push(splitCells(row, item.header.length).map((cell, i) => {\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell),\n                    header: false,\n                    align: item.align[i],\n                };\n            }));\n        }\n        return item;\n    }\n    lheading(src) {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[2].charAt(0) === '=' ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1]),\n            };\n        }\n    }\n    paragraph(src) {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n                ? cap[1].slice(0, -1)\n                : cap[1];\n            return {\n                type: 'paragraph',\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text),\n            };\n        }\n    }\n    text(src) {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: 'text',\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0]),\n            };\n        }\n    }\n    escape(src) {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: 'escape',\n                raw: cap[0],\n                text: cap[1],\n            };\n        }\n    }\n    tag(src) {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            }\n            else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            }\n            else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: 'html',\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: cap[0],\n            };\n        }\n    }\n    link(src) {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n                    return;\n                }\n                // ending angle bracket cannot be escaped\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            }\n            else {\n                // find closing parenthesis\n                const lastParenIndex = findClosingBracket(cap[2], '()');\n                if (lastParenIndex === -2) {\n                    // more open parens than closed\n                    return;\n                }\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = '';\n                }\n            }\n            let href = cap[2];\n            let title = '';\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                const link = this.rules.other.pedanticHrefTitle.exec(href);\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            }\n            else {\n                title = cap[3] ? cap[3].slice(1, -1) : '';\n            }\n            href = href.trim();\n            if (this.rules.other.startAngleBracket.test(href)) {\n                if (this.options.pedantic && !(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                }\n                else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n                title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,\n            }, cap[0], this.lexer, this.rules);\n        }\n    }\n    reflink(src, links) {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src))\n            || (cap = this.rules.inline.nolink.exec(src))) {\n            const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, ' ');\n            const link = links[linkString.toLowerCase()];\n            if (!link) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: 'text',\n                    raw: text,\n                    text,\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer, this.rules);\n        }\n    }\n    emStrong(src, maskedSrc, prevChar = '') {\n        let match = this.rules.inline.emStrongLDelim.exec(src);\n        if (!match)\n            return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric))\n            return;\n        const nextChar = match[1] || match[2] || '';\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n            const lLength = [...match[0]].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n            endReg.lastIndex = 0;\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while ((match = endReg.exec(maskedSrc)) != null) {\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim)\n                    continue; // skip single * in __abc*abc__\n                rLength = [...rDelim].length;\n                if (match[3] || match[4]) { // found another Left Delim\n                    delimTotal += rLength;\n                    continue;\n                }\n                else if (match[5] || match[6]) { // either Left or Right Delim\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue; // CommonMark Emphasis Rules 9-10\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0)\n                    continue; // Haven't found enough closing delimiters\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                // char length can be >1 for unicode characters;\n                const lastCharLength = [...match[0]][0].length;\n                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    const text = raw.slice(1, -1);\n                    return {\n                        type: 'em',\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text),\n                    };\n                }\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                const text = raw.slice(2, -2);\n                return {\n                    type: 'strong',\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text),\n                };\n            }\n        }\n    }\n    codespan(src) {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(this.rules.other.newLineCharGlobal, ' ');\n            const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);\n            const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            return {\n                type: 'codespan',\n                raw: cap[0],\n                text,\n            };\n        }\n    }\n    br(src) {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: 'br',\n                raw: cap[0],\n            };\n        }\n    }\n    del(src) {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: 'del',\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2]),\n            };\n        }\n    }\n    autolink(src) {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = cap[1];\n                href = 'mailto:' + text;\n            }\n            else {\n                text = cap[1];\n                href = text;\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    },\n                ],\n            };\n        }\n    }\n    url(src) {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = cap[0];\n                href = 'mailto:' + text;\n            }\n            else {\n                // do extended autolink path validation\n                let prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n                } while (prevCapZero !== cap[0]);\n                text = cap[0];\n                if (cap[1] === 'www.') {\n                    href = 'http://' + cap[0];\n                }\n                else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    },\n                ],\n            };\n        }\n    }\n    inlineText(src) {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            const escaped = this.lexer.state.inRawBlock;\n            return {\n                type: 'text',\n                raw: cap[0],\n                text: cap[0],\n                escaped,\n            };\n        }\n    }\n}\n","import { _Tokenizer } from './Tokenizer.ts';\nimport { _defaults } from './defaults.ts';\nimport { other, block, inline } from './rules.ts';\n/**\n * Block Lexer\n */\nexport class _Lexer {\n    tokens;\n    options;\n    state;\n    tokenizer;\n    inlineQueue;\n    constructor(options) {\n        // TokenList cannot be created in one go\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || _defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true,\n        };\n        const rules = {\n            other,\n            block: block.normal,\n            inline: inline.normal,\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        }\n        else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            }\n            else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */\n    static get rules() {\n        return {\n            block,\n            inline,\n        };\n    }\n    /**\n     * Static Lex Method\n     */\n    static lex(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */\n    static lexInline(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */\n    lex(src) {\n        src = src.replace(other.carriageReturn, '\\n');\n        this.blockTokens(src, this.tokens);\n        for (let i = 0; i < this.inlineQueue.length; i++) {\n            const next = this.inlineQueue[i];\n            this.inlineTokens(next.src, next.tokens);\n        }\n        this.inlineQueue = [];\n        return this.tokens;\n    }\n    blockTokens(src, tokens = [], lastParagraphClipped = false) {\n        if (this.options.pedantic) {\n            src = src.replace(other.tabCharGlobal, '    ').replace(other.spaceLine, '');\n        }\n        while (src) {\n            let token;\n            if (this.options.extensions?.block?.some((extTokenizer) => {\n                if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (token.raw.length === 1 && lastToken !== undefined) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    lastToken.raw += '\\n';\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.raw;\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                }\n                else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title,\n                    };\n                }\n                continue;\n            }\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            let cutSrc = src;\n            if (this.options.extensions?.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                const lastToken = tokens.at(-1);\n                if (lastParagraphClipped && lastToken?.type === 'paragraph') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = cutSrc.length !== src.length;\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === 'text') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                }\n                else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    }\n    inline(src, tokens = []) {\n        this.inlineQueue.push({ src, tokens });\n        return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */\n    inlineTokens(src, tokens = []) {\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match = null;\n        // Mask out reflinks\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n                    if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index)\n                            + '[' + 'a'.repeat(match[0].length - 2) + ']'\n                            + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out escaped characters\n        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n        // Mask out other blocks\n        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        let keepPrevChar = false;\n        let prevChar = '';\n        while (src) {\n            if (!keepPrevChar) {\n                prevChar = '';\n            }\n            keepPrevChar = false;\n            let token;\n            // extensions\n            if (this.options.extensions?.inline?.some((extTokenizer) => {\n                if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (token.type === 'text' && lastToken?.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // autolink\n            if (token = this.tokenizer.autolink(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            let cutSrc = src;\n            if (this.options.extensions?.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                }\n                else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    }\n}\n","import { _defaults } from './defaults.ts';\nimport { cleanUrl, escape, } from './helpers.ts';\nimport { other } from './rules.ts';\n/**\n * Renderer\n */\nexport class _Renderer {\n    options;\n    parser; // set by the parser\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    space(token) {\n        return '';\n    }\n    code({ text, lang, escaped }) {\n        const langString = (lang || '').match(other.notSpaceStart)?.[0];\n        const code = text.replace(other.endingNewline, '') + '\\n';\n        if (!langString) {\n            return '<pre><code>'\n                + (escaped ? code : escape(code, true))\n                + '</code></pre>\\n';\n        }\n        return '<pre><code class=\"language-'\n            + escape(langString)\n            + '\">'\n            + (escaped ? code : escape(code, true))\n            + '</code></pre>\\n';\n    }\n    blockquote({ tokens }) {\n        const body = this.parser.parse(tokens);\n        return `<blockquote>\\n${body}</blockquote>\\n`;\n    }\n    html({ text }) {\n        return text;\n    }\n    heading({ tokens, depth }) {\n        return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n`;\n    }\n    hr(token) {\n        return '<hr>\\n';\n    }\n    list(token) {\n        const ordered = token.ordered;\n        const start = token.start;\n        let body = '';\n        for (let j = 0; j < token.items.length; j++) {\n            const item = token.items[j];\n            body += this.listitem(item);\n        }\n        const type = ordered ? 'ol' : 'ul';\n        const startAttr = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n        return '<' + type + startAttr + '>\\n' + body + '</' + type + '>\\n';\n    }\n    listitem(item) {\n        let itemBody = '';\n        if (item.task) {\n            const checkbox = this.checkbox({ checked: !!item.checked });\n            if (item.loose) {\n                if (item.tokens[0]?.type === 'paragraph') {\n                    item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                        item.tokens[0].tokens[0].text = checkbox + ' ' + escape(item.tokens[0].tokens[0].text);\n                        item.tokens[0].tokens[0].escaped = true;\n                    }\n                }\n                else {\n                    item.tokens.unshift({\n                        type: 'text',\n                        raw: checkbox + ' ',\n                        text: checkbox + ' ',\n                        escaped: true,\n                    });\n                }\n            }\n            else {\n                itemBody += checkbox + ' ';\n            }\n        }\n        itemBody += this.parser.parse(item.tokens, !!item.loose);\n        return `<li>${itemBody}</li>\\n`;\n    }\n    checkbox({ checked }) {\n        return '<input '\n            + (checked ? 'checked=\"\" ' : '')\n            + 'disabled=\"\" type=\"checkbox\">';\n    }\n    paragraph({ tokens }) {\n        return `<p>${this.parser.parseInline(tokens)}</p>\\n`;\n    }\n    table(token) {\n        let header = '';\n        // header\n        let cell = '';\n        for (let j = 0; j < token.header.length; j++) {\n            cell += this.tablecell(token.header[j]);\n        }\n        header += this.tablerow({ text: cell });\n        let body = '';\n        for (let j = 0; j < token.rows.length; j++) {\n            const row = token.rows[j];\n            cell = '';\n            for (let k = 0; k < row.length; k++) {\n                cell += this.tablecell(row[k]);\n            }\n            body += this.tablerow({ text: cell });\n        }\n        if (body)\n            body = `<tbody>${body}</tbody>`;\n        return '<table>\\n'\n            + '<thead>\\n'\n            + header\n            + '</thead>\\n'\n            + body\n            + '</table>\\n';\n    }\n    tablerow({ text }) {\n        return `<tr>\\n${text}</tr>\\n`;\n    }\n    tablecell(token) {\n        const content = this.parser.parseInline(token.tokens);\n        const type = token.header ? 'th' : 'td';\n        const tag = token.align\n            ? `<${type} align=\"${token.align}\">`\n            : `<${type}>`;\n        return tag + content + `</${type}>\\n`;\n    }\n    /**\n     * span level renderer\n     */\n    strong({ tokens }) {\n        return `<strong>${this.parser.parseInline(tokens)}</strong>`;\n    }\n    em({ tokens }) {\n        return `<em>${this.parser.parseInline(tokens)}</em>`;\n    }\n    codespan({ text }) {\n        return `<code>${escape(text, true)}</code>`;\n    }\n    br(token) {\n        return '<br>';\n    }\n    del({ tokens }) {\n        return `<del>${this.parser.parseInline(tokens)}</del>`;\n    }\n    link({ href, title, tokens }) {\n        const text = this.parser.parseInline(tokens);\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + (escape(title)) + '\"';\n        }\n        out += '>' + text + '</a>';\n        return out;\n    }\n    image({ href, title, text, tokens }) {\n        if (tokens) {\n            text = this.parser.parseInline(tokens, this.parser.textRenderer);\n        }\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return escape(text);\n        }\n        href = cleanHref;\n        let out = `<img src=\"${href}\" alt=\"${text}\"`;\n        if (title) {\n            out += ` title=\"${escape(title)}\"`;\n        }\n        out += '>';\n        return out;\n    }\n    text(token) {\n        return 'tokens' in token && token.tokens\n            ? this.parser.parseInline(token.tokens)\n            : ('escaped' in token && token.escaped ? token.text : escape(token.text));\n    }\n}\n","/**\n * TextRenderer\n * returns only the textual part of the token\n */\nexport class _TextRenderer {\n    // no need for block level renderers\n    strong({ text }) {\n        return text;\n    }\n    em({ text }) {\n        return text;\n    }\n    codespan({ text }) {\n        return text;\n    }\n    del({ text }) {\n        return text;\n    }\n    html({ text }) {\n        return text;\n    }\n    text({ text }) {\n        return text;\n    }\n    link({ text }) {\n        return '' + text;\n    }\n    image({ text }) {\n        return '' + text;\n    }\n    br() {\n        return '';\n    }\n}\n","import { _Renderer } from './Renderer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { _defaults } from './defaults.ts';\n/**\n * Parsing & Compiling\n */\nexport class _Parser {\n    options;\n    renderer;\n    textRenderer;\n    constructor(options) {\n        this.options = options || _defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.renderer.parser = this;\n        this.textRenderer = new _TextRenderer();\n    }\n    /**\n     * Static Parse Method\n     */\n    static parse(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */\n    static parseInline(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */\n    parse(tokens, top = true) {\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n            const anyToken = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions?.renderers?.[anyToken.type]) {\n                const genericToken = anyToken;\n                const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n                if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch (token.type) {\n                case 'space': {\n                    out += this.renderer.space(token);\n                    continue;\n                }\n                case 'hr': {\n                    out += this.renderer.hr(token);\n                    continue;\n                }\n                case 'heading': {\n                    out += this.renderer.heading(token);\n                    continue;\n                }\n                case 'code': {\n                    out += this.renderer.code(token);\n                    continue;\n                }\n                case 'table': {\n                    out += this.renderer.table(token);\n                    continue;\n                }\n                case 'blockquote': {\n                    out += this.renderer.blockquote(token);\n                    continue;\n                }\n                case 'list': {\n                    out += this.renderer.list(token);\n                    continue;\n                }\n                case 'html': {\n                    out += this.renderer.html(token);\n                    continue;\n                }\n                case 'paragraph': {\n                    out += this.renderer.paragraph(token);\n                    continue;\n                }\n                case 'text': {\n                    let textToken = token;\n                    let body = this.renderer.text(textToken);\n                    while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n                        textToken = tokens[++i];\n                        body += '\\n' + this.renderer.text(textToken);\n                    }\n                    if (top) {\n                        out += this.renderer.paragraph({\n                            type: 'paragraph',\n                            raw: body,\n                            text: body,\n                            tokens: [{ type: 'text', raw: body, text: body, escaped: true }],\n                        });\n                    }\n                    else {\n                        out += body;\n                    }\n                    continue;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */\n    parseInline(tokens, renderer = this.renderer) {\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n            const anyToken = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions?.renderers?.[anyToken.type]) {\n                const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);\n                if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch (token.type) {\n                case 'escape': {\n                    out += renderer.text(token);\n                    break;\n                }\n                case 'html': {\n                    out += renderer.html(token);\n                    break;\n                }\n                case 'link': {\n                    out += renderer.link(token);\n                    break;\n                }\n                case 'image': {\n                    out += renderer.image(token);\n                    break;\n                }\n                case 'strong': {\n                    out += renderer.strong(token);\n                    break;\n                }\n                case 'em': {\n                    out += renderer.em(token);\n                    break;\n                }\n                case 'codespan': {\n                    out += renderer.codespan(token);\n                    break;\n                }\n                case 'br': {\n                    out += renderer.br(token);\n                    break;\n                }\n                case 'del': {\n                    out += renderer.del(token);\n                    break;\n                }\n                case 'text': {\n                    out += renderer.text(token);\n                    break;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n}\n","import { _defaults } from './defaults.ts';\nimport { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nexport class _Hooks {\n    options;\n    block;\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    static passThroughHooks = new Set([\n        'preprocess',\n        'postprocess',\n        'processAllTokens',\n    ]);\n    /**\n     * Process markdown before marked\n     */\n    preprocess(markdown) {\n        return markdown;\n    }\n    /**\n     * Process HTML after marked is finished\n     */\n    postprocess(html) {\n        return html;\n    }\n    /**\n     * Process all tokens before walk tokens\n     */\n    processAllTokens(tokens) {\n        return tokens;\n    }\n    /**\n     * Provide function to tokenize markdown\n     */\n    provideLexer() {\n        return this.block ? _Lexer.lex : _Lexer.lexInline;\n    }\n    /**\n     * Provide function to parse tokens\n     */\n    provideParser() {\n        return this.block ? _Parser.parse : _Parser.parseInline;\n    }\n}\n","import { _getDefaults } from './defaults.ts';\nimport { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport { _Hooks } from './Hooks.ts';\nimport { _Renderer } from './Renderer.ts';\nimport { _Tokenizer } from './Tokenizer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { escape } from './helpers.ts';\nexport class Marked {\n    defaults = _getDefaults();\n    options = this.setOptions;\n    parse = this.parseMarkdown(true);\n    parseInline = this.parseMarkdown(false);\n    Parser = _Parser;\n    Renderer = _Renderer;\n    TextRenderer = _TextRenderer;\n    Lexer = _Lexer;\n    Tokenizer = _Tokenizer;\n    Hooks = _Hooks;\n    constructor(...args) {\n        this.use(...args);\n    }\n    /**\n     * Run callback for every token\n     */\n    walkTokens(tokens, callback) {\n        let values = [];\n        for (const token of tokens) {\n            values = values.concat(callback.call(this, token));\n            switch (token.type) {\n                case 'table': {\n                    const tableToken = token;\n                    for (const cell of tableToken.header) {\n                        values = values.concat(this.walkTokens(cell.tokens, callback));\n                    }\n                    for (const row of tableToken.rows) {\n                        for (const cell of row) {\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                    }\n                    break;\n                }\n                case 'list': {\n                    const listToken = token;\n                    values = values.concat(this.walkTokens(listToken.items, callback));\n                    break;\n                }\n                default: {\n                    const genericToken = token;\n                    if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                        this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n                            const tokens = genericToken[childTokens].flat(Infinity);\n                            values = values.concat(this.walkTokens(tokens, callback));\n                        });\n                    }\n                    else if (genericToken.tokens) {\n                        values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                    }\n                }\n            }\n        }\n        return values;\n    }\n    use(...args) {\n        const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };\n        args.forEach((pack) => {\n            // copy options to new object\n            const opts = { ...pack };\n            // set async to true if it was set to true before\n            opts.async = this.defaults.async || opts.async || false;\n            // ==-- Parse \"addon\" extensions --== //\n            if (pack.extensions) {\n                pack.extensions.forEach((ext) => {\n                    if (!ext.name) {\n                        throw new Error('extension name required');\n                    }\n                    if ('renderer' in ext) { // Renderer extensions\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function (...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args);\n                                }\n                                return ret;\n                            };\n                        }\n                        else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if ('tokenizer' in ext) { // Tokenizer Extensions\n                        if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n                            throw new Error(\"extension level must be 'block' or 'inline'\");\n                        }\n                        const extLevel = extensions[ext.level];\n                        if (extLevel) {\n                            extLevel.unshift(ext.tokenizer);\n                        }\n                        else {\n                            extensions[ext.level] = [ext.tokenizer];\n                        }\n                        if (ext.start) { // Function to check for start of token\n                            if (ext.level === 'block') {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                }\n                                else {\n                                    extensions.startBlock = [ext.start];\n                                }\n                            }\n                            else if (ext.level === 'inline') {\n                                if (extensions.startInline) {\n                                    extensions.startInline.push(ext.start);\n                                }\n                                else {\n                                    extensions.startInline = [ext.start];\n                                }\n                            }\n                        }\n                    }\n                    if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n            // ==-- Parse \"overwrite\" extensions --== //\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                for (const prop in pack.renderer) {\n                    if (!(prop in renderer)) {\n                        throw new Error(`renderer '${prop}' does not exist`);\n                    }\n                    if (['options', 'parser'].includes(prop)) {\n                        // ignore options property\n                        continue;\n                    }\n                    const rendererProp = prop;\n                    const rendererFunc = pack.renderer[rendererProp];\n                    const prevRenderer = renderer[rendererProp];\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[rendererProp] = (...args) => {\n                        let ret = rendererFunc.apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret || '';\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                for (const prop in pack.tokenizer) {\n                    if (!(prop in tokenizer)) {\n                        throw new Error(`tokenizer '${prop}' does not exist`);\n                    }\n                    if (['options', 'rules', 'lexer'].includes(prop)) {\n                        // ignore options, rules, and lexer properties\n                        continue;\n                    }\n                    const tokenizerProp = prop;\n                    const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                    const prevTokenizer = tokenizer[tokenizerProp];\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    // @ts-expect-error cannot type tokenizer function dynamically\n                    tokenizer[tokenizerProp] = (...args) => {\n                        let ret = tokenizerFunc.apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n            // ==-- Parse Hooks extensions --== //\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new _Hooks();\n                for (const prop in pack.hooks) {\n                    if (!(prop in hooks)) {\n                        throw new Error(`hook '${prop}' does not exist`);\n                    }\n                    if (['options', 'block'].includes(prop)) {\n                        // ignore options and block properties\n                        continue;\n                    }\n                    const hooksProp = prop;\n                    const hooksFunc = pack.hooks[hooksProp];\n                    const prevHook = hooks[hooksProp];\n                    if (_Hooks.passThroughHooks.has(prop)) {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (arg) => {\n                            if (this.defaults.async) {\n                                return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    }\n                    else {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (...args) => {\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n            // ==-- Parse WalkTokens extensions --== //\n            if (pack.walkTokens) {\n                const walkTokens = this.defaults.walkTokens;\n                const packWalktokens = pack.walkTokens;\n                opts.walkTokens = function (token) {\n                    let values = [];\n                    values.push(packWalktokens.call(this, token));\n                    if (walkTokens) {\n                        values = values.concat(walkTokens.call(this, token));\n                    }\n                    return values;\n                };\n            }\n            this.defaults = { ...this.defaults, ...opts };\n        });\n        return this;\n    }\n    setOptions(opt) {\n        this.defaults = { ...this.defaults, ...opt };\n        return this;\n    }\n    lexer(src, options) {\n        return _Lexer.lex(src, options ?? this.defaults);\n    }\n    parser(tokens, options) {\n        return _Parser.parse(tokens, options ?? this.defaults);\n    }\n    parseMarkdown(blockType) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const parse = (src, options) => {\n            const origOpt = { ...options };\n            const opt = { ...this.defaults, ...origOpt };\n            const throwError = this.onError(!!opt.silent, !!opt.async);\n            // throw error if an extension set async to true but parse was called with async: false\n            if (this.defaults.async === true && origOpt.async === false) {\n                return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));\n            }\n            // throw error in case of non string input\n            if (typeof src === 'undefined' || src === null) {\n                return throwError(new Error('marked(): input parameter is undefined or null'));\n            }\n            if (typeof src !== 'string') {\n                return throwError(new Error('marked(): input parameter is of type '\n                    + Object.prototype.toString.call(src) + ', string expected'));\n            }\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n                opt.hooks.block = blockType;\n            }\n            const lexer = opt.hooks ? opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);\n            const parser = opt.hooks ? opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n                    .then(src => lexer(src, opt))\n                    .then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)\n                    .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)\n                    .then(tokens => parser(tokens, opt))\n                    .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n                    .catch(throwError);\n            }\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                let tokens = lexer(src, opt);\n                if (opt.hooks) {\n                    tokens = opt.hooks.processAllTokens(tokens);\n                }\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html = parser(tokens, opt);\n                if (opt.hooks) {\n                    html = opt.hooks.postprocess(html);\n                }\n                return html;\n            }\n            catch (e) {\n                return throwError(e);\n            }\n        };\n        return parse;\n    }\n    onError(silent, async) {\n        return (e) => {\n            e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n            if (silent) {\n                const msg = '<p>An error occurred:</p><pre>'\n                    + escape(e.message + '', true)\n                    + '</pre>';\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                return msg;\n            }\n            if (async) {\n                return Promise.reject(e);\n            }\n            throw e;\n        };\n    }\n}\n","import { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport { _Tokenizer } from './Tokenizer.ts';\nimport { _Renderer } from './Renderer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { _Hooks } from './Hooks.ts';\nimport { Marked } from './Instance.ts';\nimport { _getDefaults, changeDefaults, _defaults, } from './defaults.ts';\nconst markedInstance = new Marked();\nexport function marked(src, opt) {\n    return markedInstance.parse(src, opt);\n}\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */\nmarked.options =\n    marked.setOptions = function (options) {\n        markedInstance.setOptions(options);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n/**\n * Gets the original marked default options.\n */\nmarked.getDefaults = _getDefaults;\nmarked.defaults = _defaults;\n/**\n * Use Extension\n */\nmarked.use = function (...args) {\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Run callback for every token\n */\nmarked.walkTokens = function (tokens, callback) {\n    return markedInstance.walkTokens(tokens, callback);\n};\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */\nmarked.parseInline = markedInstance.parseInline;\n/**\n * Expose\n */\nmarked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\nexport const options = marked.options;\nexport const setOptions = marked.setOptions;\nexport const use = marked.use;\nexport const walkTokens = marked.walkTokens;\nexport const parseInline = marked.parseInline;\nexport const parse = marked;\nexport const parser = _Parser.parse;\nexport const lexer = _Lexer.lex;\nexport { _defaults as defaults, _getDefaults as getDefaults } from './defaults.ts';\nexport { _Lexer as Lexer } from './Lexer.ts';\nexport { _Parser as Parser } from './Parser.ts';\nexport { _Tokenizer as Tokenizer } from './Tokenizer.ts';\nexport { _Renderer as Renderer } from './Renderer.ts';\nexport { _TextRenderer as TextRenderer } from './TextRenderer.ts';\nexport { _Hooks as Hooks } from './Hooks.ts';\nexport { Marked } from './Instance.ts';\n"],"names":["$d55025bea272cdc1$exports","factory","exports1","_getDefaults","async","breaks","extensions","gfm","hooks","pedantic","renderer","silent","tokenizer","walkTokens","changeDefaults","newDefaults","defaults","noopTest","exec","edit","regex","opt","source","obj","replace","name","val","valSource","other","caret","getRegex","RegExp","codeRemoveIndent","outputLinkReplace","indentCodeCompensation","beginningSpace","endingHash","startingSpaceChar","endingSpaceChar","nonSpaceChar","newLineCharGlobal","tabCharGlobal","multipleSpaceGlobal","blankLine","doubleBlankLine","blockquoteStart","blockquoteSetextReplace","blockquoteSetextReplace2","listReplaceTabs","listReplaceNesting","listIsTask","listReplaceTask","anyLine","hrefBrackets","tableDelimiter","tableAlignChars","tableRowBlankLine","tableAlignRight","tableAlignCenter","tableAlignLeft","startATag","endATag","startPreScriptTag","endPreScriptTag","startAngleBracket","endAngleBracket","pedanticHrefTitle","unicodeAlphaNumeric","escapeTest","escapeReplace","escapeTestNoEncode","escapeReplaceNoEncode","unescapeTest","percentDecode","findPipe","splitPipe","slashPipe","carriageReturn","spaceLine","notSpaceStart","endingNewline","listItemRegex","bull","nextBulletRegex","indent","Math","min","hrRegex","fencesBeginRegex","headingBeginRegex","htmlBeginRegex","hr","bullet","lheadingCore","lheading","lheadingGfm","_paragraph","_blockLabel","def","list","_tag","_comment","html","paragraph","blockNormal","blockquote","code","fences","heading","newline","table","text","gfmTable","blockGfm","blockPedantic","br","_punctuation","_punctuationOrSpace","_notPunctuationOrSpace","punctuation","_punctuationGfmStrongEm","emStrongLDelimCore","emStrongLDelim","emStrongLDelimGfm","emStrongRDelimAstCore","emStrongRDelimAst","emStrongRDelimAstGfm","emStrongRDelimUnd","anyPunctuation","autolink","_inlineComment","tag","_inlineLabel","link","reflink","nolink","reflinkSearch","inlineNormal","_backpedal","blockSkip","del","escape","url","inlinePedantic","inlineGfm","inlineBreaks","block","normal","inline","escapeReplacements","getEscapeReplacement","ch","encode","test","cleanUrl","href","encodeURI","splitCells","tableRow","count","cells","row","match","offset","str","escaped","curr","split","i","trim","shift","length","at","pop","splice","push","rtrim","c","invert","l","suffLen","currChar","charAt","slice","outputLink","cap","raw","lexer","rules","title","state","inLink","token","type","tokens","inlineTokens","_Tokenizer","options","constructor","space","src","codeBlockStyle","matchIndentToCode","indentToCode","map","node","matchIndentInNode","indentInNode","join","lang","trimmed","depth","lines","inBlockquote","currentLines","currentRaw","currentText","top","blockTokens","lastToken","newText","oldToken","newToken","substring","isordered","ordered","start","loose","items","itemRegex","endsWithBlankLine","ischecked","endEarly","itemContents","line","t","repeat","nextLine","trimStart","search","nextLineWithoutTabs","rawLine","istask","task","checked","lastItem","trimEnd","spacers","filter","some","pre","toLowerCase","headers","aligns","rows","item","header","align","cell","inRawBlock","trimmedUrl","rtrimSlash","lastParenIndex","findClosingBracket","b","indexOf","level","linkLen","links","linkString","emStrong","maskedSrc","prevChar","lLength","rDelim","rLength","delimTotal","midDelimTotal","endReg","lastIndex","lastCharLength","index","codespan","hasNonSpaceChars","hasSpaceCharsOnBothEnds","prevCapZero","inlineText","_Lexer","inlineQueue","Object","create","lex","lexInline","next","lastParagraphClipped","extTokenizer","call","undefined","cutSrc","startBlock","tempStart","startIndex","Infinity","tempSrc","forEach","getStartIndex","errMsg","charCodeAt","console","error","Error","keys","includes","lastIndexOf","keepPrevChar","startInline","_Renderer","parser","langString","body","parse","parseInline","j","listitem","itemBody","checkbox","unshift","tablecell","tablerow","k","content","strong","em","cleanHref","out","image","textRenderer","_TextRenderer","_Parser","anyToken","renderers","ret","genericToken","textToken","_Hooks","passThroughHooks","Set","preprocess","markdown","postprocess","processAllTokens","provideLexer","provideParser","Marked","setOptions","parseMarkdown","Parser","Renderer","TextRenderer","Lexer","Tokenizer","Hooks","args","use","callback","values","concat","tableToken","listToken","childTokens","flat","pack","opts","ext","prevRenderer","apply","extLevel","prop","rendererFunc","tokenizerFunc","prevTokenizer","hooksFunc","prevHook","has","arg","Promise","resolve","then","packWalktokens","blockType","origOpt","throwError","onError","prototype","toString","all","catch","e","message","msg","reject","markedInstance","marked","getDefaults","$b453c56ec4aeb0a8$var$chatLog","document","getElementById","$b453c56ec4aeb0a8$var$promptInput","$b453c56ec4aeb0a8$var$sendButton","$b453c56ec4aeb0a8$var$currentModel","$b453c56ec4aeb0a8$var$getResponse","prompt","value","response","fetch","method","JSON","stringify","model","stream","ok","status","statusText","innerHTML","reader","getReader","decoder","TextDecoder","fullReply","userMsg","createElement","appendChild","botMsg","done","read","chunk","decode","data","err","addEventListener","event","key","modelContainer","innerText","_defaults"],"version":3,"file":"popup.f7223817.js.map"}